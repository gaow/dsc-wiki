diff --git a/README.md b/README.md
index 220291f..3cf6db9 100644
--- a/README.md
+++ b/README.md
@@ -14,6 +14,12 @@ This work is supported by the the Gordon and Betty Moore Foundation via an Inves
 
 ### 0.2.x
 
+0.2.6.2
+
+* Add, by default, a variable `DSC_DEBUG` to output files that saves parameters used to generate the output.
+* Enhance `R()` operator due to use of [`dscrutils`](https://github.com/stephenslab/dsc2/tree/master/dscrutils) package. This packages is now required to parse DSC file when `R` modules are involved.
+* [minor] Various bug fixes.
+
 0.2.6.1
 
 * Internally replace `RDS` format with `HDF5` format for Python routines. **Pipeline with mixed languages is now officially broken at this point until the next major release that supports `HDF5` in R**.
diff --git a/src/dsc_parser.py b/src/dsc_parser.py
index 09c8c27..f6c827d 100644
--- a/src/dsc_parser.py
+++ b/src/dsc_parser.py
@@ -11,7 +11,7 @@ import os, re, itertools, copy, subprocess, platform
 import collections
 from xxhash import xxh32 as xxh
 from sos.utils import env
-from .utils import FormatError, strip_dict, find_nested_key, get_nested_keys, merge_lists, flatten_list, uniq_list, \
+from .utils import FormatError, strip_dict, find_nested_key, get_nested_keys, merge_lists, flatten_list, uniq_list, cartesian_list, \
      try_get_value, dict2str, set_nested_value, update_nested_dict, locate_file, filter_sublist, OrderedDict, \
      yaml
 from .addict import Dict as dotdict
@@ -142,37 +142,46 @@ class DSC_Script:
         Name of derived blocks looks like: "derived(base)"
         This function first figures out sorted block names such that derived block always follows the base block
         Then it propagate self.content derived blocks
+        derived : {block: derived_block, base_block}
+        base: {module: base_block}
         '''
-        base = []
         blocks = []
-        derived = dict()
+        base = OrderedDict()
+        derived = OrderedDict()
         for block in self.content:
-            groups = DSC_DERIVED_BLOCK.search(block.strip())
+            groups = DSC_DERIVED_BLOCK.search(block)
             if groups:
-                derived[block] = (groups.group(1).strip(), groups.group(2).strip())
+                derived[block] = (groups.group(1), groups.group(2))
+                if ',' in derived[block][1]:
+                    raise FormatError(f"Invalid base module name ``{derived[block][1]}``. Base module has to be single module.")
             else:
-                base.append(block)
+                for bb in block.split(','):
+                    base[bb] = block
                 blocks.append(block)
         if len(derived) == 0:
             return
-        # Check looped derivations: x(y) and y(x)
-        tmp = [sorted(x) for x in derived.values()]
-        for item in ((i, tmp.count(i)) for i in tmp):
-            if item[1] > 1:
-                raise FormatError(f"Looped block inheritance: {item[0][0]}({item[0][1]}) and {item[0][1]}({item[0][0]})!")
+        # get module level derivation
+        # [(derived, base), ()...]
+        tmp = sum([cartesian_list(*[y.split(',') for y in x]) for x in derived.values()], [])
         # Check self-derivation and non-existing base
-        tmp = base + [x[0] for x in derived.values()]
-        for item in derived.values():
+        for item in tmp:
             if item[0] == item[1]:
                 raise FormatError(f"Looped block inheritance: {item[0]}({item[0]})!")
-            if item[1] not in tmp:
+            if item[1] not in base and item[1] not in [x[0] for x in tmp]:
                 raise FormatError(f"Base block ``{item[1]}`` does not exist for {item[0]}({item[1]})!")
+        # now create duplicates by swapping
+        # and looped derivations: x(y) and y(x)
+        tmp = [sorted(x) for x in tmp]
+        for item in ((i, tmp.count(i)) for i in tmp):
+            if item[1] > 1:
+                raise FormatError(f"Looped block inheritance: {item[0][0]}({item[0][1]}) and {item[0][1]}({item[0][0]})!")
         #
         derived_cycle = itertools.cycle(derived.values())
         while True:
             item = next(derived_cycle)
             if item[1] in base:
-                base.append(item[0])
+                for bb in item[0].split(','):
+                    base[bb] = item[0]
                 name = f'{item[0]}({item[1]})'
                 if name not in blocks:
                     blocks.append(name)
@@ -181,8 +190,12 @@ class DSC_Script:
         # propagate data
         for block in blocks:
             if block in derived:
-                self.content[derived[block][0]] = update_nested_dict(
-                    copy.deepcopy(self.content[derived[block][1]]), self.content[block])
+                tmp = copy.deepcopy(self.content[base[derived[block][1]]])
+                # now there is one exception to handle: what if tmp has @derived[block][1] decorator in it?
+                if f'^{derived[block][1]}' in tmp:
+                    tmp.update(tmp[f'^{derived[block][1]}'])
+                    del tmp[f'^{derived[block][1]}']
+                self.content[derived[block][0]] = update_nested_dict(tmp, self.content[block])
                 del self.content[block]
         return
 
diff --git a/test/test_parser.ipynb b/test/test_parser.ipynb
index 3e4be63..feb5135 100644
--- a/test/test_parser.ipynb
+++ b/test/test_parser.ipynb
@@ -23,6 +23,7 @@
     "    try:\n",
     "        return obj(*args)\n",
     "    except Exception as e:\n",
+    "        #raise\n",
     "        assert type(e).__name__ == 'FormatError'\n",
     "        print(e)\n",
     "        return None"
@@ -485,7 +486,7 @@
    "cell_type": "markdown",
    "metadata": {},
    "source": [
-    "## Omit executable in derived modules"
+    "## Module derivation"
    ]
   },
   {
@@ -520,7 +521,7 @@
   },
   {
    "cell_type": "code",
-   "execution_count": 15,
+   "execution_count": 1,
    "metadata": {
     "kernel": "SoS"
    },
@@ -555,6 +556,150 @@
     "res = test_format(ds, text)\n",
     "assert res.modules['simulate'].dump()['command'] == 'test.R'"
    ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 2,
+   "metadata": {
+    "kernel": "SoS"
+   },
+   "outputs": [
+    {
+     "name": "stdout",
+     "output_type": "stream",
+     "text": [
+      "Invalid base module name ``normal,t``. Base module has to be single module.\n"
+     ]
+    }
+   ],
+   "source": [
+    "%run\n",
+    "[14]\n",
+    "# P: derive from compact\n",
+    "text = '''\n",
+    "normal, t: rnorm.R, rt.R\n",
+    "    n: 1000\n",
+    "    @normal:\n",
+    "        y: 5\n",
+    "        n: 6\n",
+    "    $x: x\n",
+    "    \n",
+    "shifted_normal(normal, t): \n",
+    "    mu: 1\n",
+    "DSC:\n",
+    "    run: test\n",
+    "'''\n",
+    "res = test_format(ds, text)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 3,
+   "metadata": {
+    "kernel": "SoS"
+   },
+   "outputs": [
+    {
+     "name": "stdout",
+     "output_type": "stream",
+     "text": [
+      "``1`` modules ``['shifted_normal']`` does not match ``2`` executables ``['rnorm.R', 'rt.R']``. Please ensure modules and executables match.\n"
+     ]
+    }
+   ],
+   "source": [
+    "%run\n",
+    "[15]\n",
+    "# P: derive from one of compact\n",
+    "text = '''\n",
+    "normal, t: rnorm.R, rt.R\n",
+    "    n: 1000\n",
+    "    @normal:\n",
+    "        y: 5\n",
+    "        n: 6\n",
+    "    $x: x\n",
+    "    \n",
+    "shifted_normal(normal):\n",
+    "    mu: 1\n",
+    "DSC:\n",
+    "    run: test\n",
+    "'''\n",
+    "res = test_format(ds, text)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 1,
+   "metadata": {
+    "kernel": "SoS"
+   },
+   "outputs": [
+    {
+     "name": "stdout",
+     "output_type": "stream",
+     "text": [
+      "Looped block inheritance: normal(shifted_normal) and shifted_normal(normal)!\n"
+     ]
+    }
+   ],
+   "source": [
+    "%run\n",
+    "[16]\n",
+    "# F: looped\n",
+    "text = '''\n",
+    "normal, t (shifted_normal): rnorm.R, rt.R\n",
+    "    n: 1000\n",
+    "    @normal:\n",
+    "        y: 5\n",
+    "        n: 6\n",
+    "    $x: x\n",
+    "    \n",
+    "shifted_normal(normal): \n",
+    "    mu: 1\n",
+    "DSC:\n",
+    "    run: test\n",
+    "'''\n",
+    "res = test_format(ds, text)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 2,
+   "metadata": {
+    "kernel": "SoS"
+   },
+   "outputs": [
+    {
+     "name": "stdout",
+     "output_type": "stream",
+     "text": [
+      "Base block ``base1`` does not exist for simulate(base1)!\n"
+     ]
+    }
+   ],
+   "source": [
+    "%run\n",
+    "[17]\n",
+    "# F: non-existing base\n",
+    "text = '''\n",
+    "base: sim.R\n",
+    "    x: 2\n",
+    "simulate(base1): \n",
+    "    x: R(1:5)\n",
+    "    \n",
+    "DSC:\n",
+    "    run: simulate\n",
+    "    output: dsc_test\n",
+    "'''\n",
+    "res = test_format(ds, text)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {},
+   "outputs": [],
+   "source": []
   }
  ],
  "metadata": {
