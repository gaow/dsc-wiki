<!DOCTYPE html>
<html>
<head><meta charset="utf-8" />
<title>syntax</title>

<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.1.10/require.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>








<!-- Custom stylesheet, it must be in the same directory as the html file -->
<link rel="stylesheet" href="custom.css">

<!-- Loading mathjax macro -->
<!-- Load mathjax -->
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
    <!-- MathJax configuration -->
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
            processEscapes: true,
            processEnvironments: true
        },
        // Center justify equations in code and markdown cells. Elsewhere
        // we use CSS to left justify single line equations in code cells.
        displayAlign: 'center',
        "HTML-CSS": {
            styles: {'.MathJax_Display': {"margin": 0}},
            linebreaks: { automatic: true }
        }
    });
    </script>
    <!-- End of mathjax configuration --></head>

 <link rel="stylesheet" href="http://code.jquery.com/ui/1.11.4/themes/smoothness/jquery-ui.css">

<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jqueryui/1.9.1/jquery-ui.min.js"></script>

<style>  /* defined here in case the main.css below cannot be loaded */
.lev1 {margin-left: 80px}
.lev2 {margin-left: 100px}
.lev3 {margin-left: 120px}
.lev4 {margin-left: 140px}
.lev5 {margin-left: 160px}
.lev6 {margin-left: 180px}
</style>

<link rel="stylesheet" type="text/css" href="../../css/jt.css">
<link rel="stylesheet" type="text/css" href="../../css/toc2.css">

<script src="../../js/toc2.js"></script>
<script src="../../js/docs.js"></script>

<script>
    MathJax.Hub.Config({
        "HTML-CSS": {
            preferredFont: "TeX",
            availableFonts: ["STIX","TeX"],
            styles: {
                scale: 110,
                ".MathJax_Display": {
                    "font-size": "110%",
                }
            }
        }
    });
</script>

<script>
$( document ).ready(function(){

            var cfg={'threshold':3,     // depth of toc (number of levels)
             // 'number_sections': false,  // sections numbering
             'number_sections': false, 
             'toc_cell': false,          // useless here
             'toc_window_display': true, // display the toc window
             "toc_section_display": "block", // display toc contents in the window
             // 'sideBar':false,      
             'sideBar':true,       // sidebar or floating window
             'navigate_menu':false       // navigation menu (only in liveNotebook -- do not change)
            }

            var st={};                  // some variables used in the script
            st.rendering_toc_cell = false;
            st.config_loaded = false;
            st.extension_initialized=false;
            st.nbcontainer_marginleft = $('#notebook-container').css('margin-left')
            st.nbcontainer_marginright = $('#notebook-container').css('margin-right')
            st.nbcontainer_width = $('#notebook-container').css('width')
            st.oldTocHeight = undefined
            st.cell_toc = undefined;
            st.toc_index=0;

            // fire the main function with these parameters



            table_of_contents(cfg,st);

            var file=documentationDict[$("h1:first").attr("id")];
            var path="http://gaow.github.io/dsc-wiki"
            $("#toc-level0 a").css("color","#126dce");
            $('a[href="#'+$("h1:first").attr("id")+'"]').hide()
            var docs=documentation;
            var pos=documentation.indexOf(file);
        
            for (var a=pos;a>=0;a--){
                  var name=docs[a]
                  $('<li><a href="'+path+'/doc/documentation/'+name+'.html">'+name.replace(/_/g," ")+'</a></li>').insertBefore("#toc-level0 li:eq(0)");
            }
            $('a[href="'+path+'/doc/documentation/'+file+'.html'+'"]').css("color","#126dce");


            $('<li id="indexHome"><a href="'+path+'/documentation.html"><b>Home<b></a></li>').insertBefore("#toc-level0 li:eq(0)");
            for (var a=pos+1;a<docs.length;a++){
                  var name=docs[a]
                  $(".toc #toc-level0").append('<li><a href="'+path+'/doc/documentation/'+name+'.html">'+name.replace(/_/g," ")+'</a></li>');
            }
            $("#toc-header").hide();

    });
</script>
<body>
  <div tabindex="-1" id="notebook" class="border-box-sizing">
    <div class="container" id="notebook-container">

<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Syntax">Syntax<a class="anchor-link" href="#Syntax">&#182;</a></h1>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="DSC-Terminology">DSC Terminology<a class="anchor-link" href="#DSC-Terminology">&#182;</a></h2><ul>
<li><strong>DSC script</strong>: A <a href="http://yaml.org">YAML</a> flavored text file that configures the entire DSC procedure.<ul>
<li>DSC script is YAML flavored but not standard YAML file.</li>
</ul>
</li>
<li><strong>DSC block</strong>: Sections in DSC script that defines a family of computational routines.</li>
<li><strong>DSC step</strong>: A computational routine defined in a DSC block.</li>
<li><strong>Block parameters</strong>: Keywords constituting a DSC block specification.<ul>
<li>Available block parameters: <code>exec</code>, <code>params</code>, <code>seed</code>, <code>return</code>, <code>.alias</code>, <code>.logic</code>, <code>.options</code></li>
</ul>
</li>
<li><strong>DSC entry</strong>: Lines in DSC blocks, labeled by block parameters and separated by comma (","), to allow for a range of values be assigned to multiple computational routines.</li>
<li><strong>Block operators</strong>: Special functions to help DSC specification, including:<ul>
<li><code>$, $(), (), R(), Python(), Shell(), Combo(), Pairs(), Asis(), File(), Pack()</code></li>
</ul>
</li>
<li><strong>The DSC Section</strong>: A special section called <code>DSC</code>, consisting of a <a href="01-Design-and-Features#Design-Overview"><strong>DSC sequence</strong></a>, plus various miscellaneous parameters to configure DSC runs.<ul>
<li>For example, required R libraries, path to executables / libraries, global variables for the DSC script, output file name and work directory.</li>
</ul>
</li>
<li><strong>DSC sequence</strong> &amp; <strong>DSC sequence operators</strong>: A sequence of logical expression that defines how the DSC blocks should be connected to each other.</li>
<li><strong>DSC variables</strong>: The <code>parameters</code> entry in the <code>DSC</code> section that defines variables to be accessed by DSC blocks (via <code>$()</code> sigil).</li>
</ul>
<p>You may glance over some <a href="03-Sample-DSC-Files">sample DSC files</a> to have an idea of DSC2 syntax. It is also recommended that you read the <a href="01-Design-and-Features">DSC design concept</a> before diving into the details throughout the rest of the document.</p>
<h2 id="DSC-Block-Parameters">DSC Block Parameters<a class="anchor-link" href="#DSC-Block-Parameters">&#182;</a></h2><p>A DSC block is composed of block parameters.</p>
<h3 id="exec-[required]">exec [required]<a class="anchor-link" href="#exec-[required]">&#182;</a></h3><p><code>exec</code> specifies the names of executable computational routines as well as their command line arguments if applicable. For example a <code>exec</code> entry reads:</p>
<div class="highlight"><pre><span></span><span class="l l-Scalar l-Scalar-Plain">exec</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">datamaker.R, ms $nsam $nreps -t $theta -seed $seed</span>
</pre></div>
<p>where data is generated by two programs, <code>datamaker.R</code> and <code>ms</code>, with command line arguments <code>nsam</code>, <code>nreps</code> and <code>theta</code> &amp; <code>seed</code> for <code>ms</code>. Although <code>exec</code> takes arbitrary command line programs, if the computational routine is <a href="01-Design-and-Features#executable-modes">a plugin</a>, for example <code>datamaker.R</code>, then there is no need to explicitly specify input parameters such as <code>nsam</code> and <code>nreps</code>, as long as the parameter names match the variable names coded inside the R script. For non-plugin such as <code>ms</code> here, input parameters should start with <code>$</code> and followed by parameter names which will be found under the <a href="#params-optional"><code>params</code></a> entry of <strong>the same block</strong>.</p>
<h3 id="params-[optional]">params [optional]<a class="anchor-link" href="#params-[optional]">&#182;</a></h3><p><code>params</code> defines parameters to be used by computational routines under <code>exec</code>. It is a indented list with labels (parameter names) corresponding to command arguments (for non-plugin mode) or variable names (for plugin mode) of <code>exec</code>. A typical <code>params</code> reads:</p>
<div class="highlight"><pre><span></span><span class="l l-Scalar l-Scalar-Plain">params</span><span class="p p-Indicator">:</span>
    <span class="l l-Scalar l-Scalar-Plain">n</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">1000, 2000</span>
    <span class="l l-Scalar l-Scalar-Plain">mean</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">0, 1</span>
</pre></div>
<p>which indicates that there are 2 input parameters, namely <code>n</code> and <code>mean</code>, for computational routines defined in <code>exec</code>. Combinations of parameter values (Cartesian product style) will be assigned to all <code>exec</code> unless <a href="#logic-optional">otherwise instructed</a>. For example, each executable under <code>exec</code> will take 4 sets of parameter from the example above: <code>(n = 1000, mean = 0), (n = 1000, mean = 1), (n = 2000, mean = 0), (n = 2000, mean = 1)</code>.</p>
<h4 id="exec-specific-parameters"><code>exec</code> specific parameters<a class="anchor-link" href="#exec-specific-parameters">&#182;</a></h4><p>Often, there are parameters unique to one <code>exec</code>. Executable specific parameter assignment is needed in this case:</p>
<div class="highlight"><pre><span></span><span class="l l-Scalar l-Scalar-Plain">params</span><span class="p p-Indicator">:</span>
    <span class="l l-Scalar l-Scalar-Plain">n</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">1000, 2000</span>
    <span class="l l-Scalar l-Scalar-Plain">mean</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">0, 1</span>
    <span class="l l-Scalar l-Scalar-Plain">exec[1]</span><span class="p p-Indicator">:</span>
      <span class="l l-Scalar l-Scalar-Plain">t</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">5, 10</span>
</pre></div>
<p>where <code>n</code> and <code>mean</code> are shared by all <code>exec</code> but parameter <code>t</code> is only used by the first executable (indexed by <code>[1]</code>) in <code>exec</code>.</p>
<h4 id="Grouped-parameters">Grouped parameters<a class="anchor-link" href="#Grouped-parameters">&#182;</a></h4><p>This is a house-keeping feature that organizes parameters in groups to enhance readability. These group names will be ignored by DSC2 interpreter in action. For example the following two blocks are equivalent:</p>
<div class="highlight"><pre><span></span><span class="l l-Scalar l-Scalar-Plain">params</span><span class="p p-Indicator">:</span>
    <span class="l l-Scalar l-Scalar-Plain">sample_params</span><span class="p p-Indicator">:</span>
      <span class="l l-Scalar l-Scalar-Plain">n_samples</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">1000, 2000</span>
      <span class="l l-Scalar l-Scalar-Plain">p_cases</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">0.5</span>
    <span class="l l-Scalar l-Scalar-Plain">genotype_params</span><span class="p p-Indicator">:</span>
      <span class="l l-Scalar l-Scalar-Plain">n_snps</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">500, 800</span>
      <span class="l l-Scalar l-Scalar-Plain">n_genes</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">20</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="l l-Scalar l-Scalar-Plain">params</span><span class="p p-Indicator">:</span>
    <span class="l l-Scalar l-Scalar-Plain">n_samples</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">1000, 2000</span>
    <span class="l l-Scalar l-Scalar-Plain">p_cases</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">0.5</span>
    <span class="l l-Scalar l-Scalar-Plain">n_snps</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">500, 800</span>
    <span class="l l-Scalar l-Scalar-Plain">n_genes</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">20</span>
</pre></div>
<h3 id="seed-[optional]">seed [optional]<a class="anchor-link" href="#seed-[optional]">&#182;</a></h3><p><code>seed</code> sets random seeds for programs that use random number generators. Setting a range of seeds naturally creates <em>replicates</em> of the same scenario or same methods. If there are plugins in <code>exec</code>, language specific functions (<code>set.seed()</code> in R and <code>[numpy].random.seed()</code> in Python) will be invoked to set seeds; otherwise the seed values will be be passed to <code>exec</code> the same fashion as other parameters in <code>params</code>, for example <code>ms ... -seed $seed</code> as demonstrated above.</p>
<h3 id="return-[required]">return [required]<a class="anchor-link" href="#return-[required]">&#182;</a></h3><p><code>return</code> parameter are values to be saved to disk at the end of computation for each block. Only <code>return</code> values of a block can be referred to by other blocks (via the <code>$</code> symbol). For example:</p>
<div class="highlight"><pre><span></span><span class="l l-Scalar l-Scalar-Plain">simulate</span><span class="p p-Indicator">:</span>
      <span class="l l-Scalar l-Scalar-Plain">...</span>
      <span class="l l-Scalar l-Scalar-Plain">return</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">x, y</span>
</pre></div>
<p>then <code>return</code> values <code>x</code>, <code>y</code> and <code>z</code> can be used in other blocks, for example,</p>
<div class="highlight"><pre><span></span><span class="l l-Scalar l-Scalar-Plain">test</span><span class="p p-Indicator">:</span>
      <span class="l l-Scalar l-Scalar-Plain">params</span><span class="p p-Indicator">:</span>
        <span class="l l-Scalar l-Scalar-Plain">x</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">$x</span>
        <span class="l l-Scalar l-Scalar-Plain">y</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">$y</span>
</pre></div>
<p>where input parameters <code>x</code> and <code>y</code> for "test" consists of values from <code>return</code> of "simulate".</p>
<p>It is possible to apply alias to return. There are two types of alias supported: extract and re-name. For example to extract a specific attribute from an R list:</p>
<div class="highlight"><pre><span></span><span class="l l-Scalar l-Scalar-Plain">return</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">data, beta = R(data$meta$beta)</span>
</pre></div>
<p>then in addition to returning <code>data</code> which is an R list, it also returns value <code>beta</code> which is part of the <code>data</code> list, i.e., <code>data$meta$beta</code>. For another example:</p>
<div class="highlight"><pre><span></span><span class="l l-Scalar l-Scalar-Plain">return</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">x, y = x_new</span>
</pre></div>
<p>where <code>x</code> and <code>x_new</code> exist in data but <code>x_new</code> is returned as another variable named <code>y</code>.</p>
<p>For plugin executables, return value should correspond to a variable name in the plugin script and thus may or may not be in <code>params</code>. For non-plugin executables, return value should be one of the <code>params</code> values. If return value is a file name (via <a href="#file">File()</a> syntax), the corresponding file will be registered to DSC2 to track its future changes.</p>
<h3 id=".logic-[optional]">.logic [optional]<a class="anchor-link" href="#.logic-[optional]">&#182;</a></h3><p><code>.logic</code> defines how parameter values are combined. It can be used outside or inside <code>params</code>.</p>
<h4 id="For-executables">For executables<a class="anchor-link" href="#For-executables">&#182;</a></h4><p>When <code>.logic</code> appears outside <code>params</code> (typically under <code>exec</code> ), it uses the <code>+</code> operator to specify how the computational routines should be combined. These routines are independent from each other by default, but can be connected via <code>.logic</code> entry, for example:</p>
<div class="highlight"><pre><span></span><span class="l l-Scalar l-Scalar-Plain">method</span><span class="p p-Indicator">:</span>
        <span class="l l-Scalar l-Scalar-Plain">exec</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">test1.R, test2.R</span>
        <span class="l l-Scalar l-Scalar-Plain">.logic</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">exec[2], exec[1] + exec[2]</span>
</pre></div>
<p>then the DSC pipeline will run two procedures: one runs only <code>test2.R</code>, the other runs <code>test1.R</code> followed by <code>test2.R</code>.</p>
<p>A handy user case for <code>.logic</code> under <code>exec</code> is pre/post processing of data from/to third-party software, for example:</p>
<div class="highlight"><pre><span></span><span class="l l-Scalar l-Scalar-Plain">admixture</span><span class="p p-Indicator">:</span>
      <span class="l l-Scalar l-Scalar-Plain">exec</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">make_ped.py $data $ped,</span>
            <span class="l l-Scalar l-Scalar-Plain">admixture $ped $K &gt; $output,</span>
            <span class="l l-Scalar l-Scalar-Plain">new_admixture_method.R $data $output</span>
      <span class="l l-Scalar l-Scalar-Plain">.logic</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">exec[1] + exec[2], exec[3]</span>
</pre></div>
<p>Here two different admixture analysis methods are compared: the <code>admixture</code> program and a new method under development, coded in <code>new_admixture_method.R</code>. The <code>admixture</code> program requires input data in PED format, and a <code>make_ped.py</code> script is used to convert data to PED. <code>.logic</code> here indicates that <code>exec[1]</code> is a pre-processor for <code>exec[2]</code> and they should always be combined into one unit.</p>
<h4 id="For-parameters">For parameters<a class="anchor-link" href="#For-parameters">&#182;</a></h4><p><em>FIXME: this feature is not yet implemented as of May 01, 2016.</em></p>
<p>When <code>.logic</code> appears inside <code>params</code>, it overrides the default logic (that all parameters are combined the Cartesian product style). <a href="#dsc-sequences">DSC sequence</a> operators are supported. For example:</p>
<div class="highlight"><pre><span></span><span class="l l-Scalar l-Scalar-Plain">params</span><span class="p p-Indicator">:</span>
    <span class="l l-Scalar l-Scalar-Plain">n</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">100, 200, 300, 400, 500</span>
    <span class="l l-Scalar l-Scalar-Plain">mu</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">0, 1</span>
    <span class="l l-Scalar l-Scalar-Plain">exec[1]</span><span class="p p-Indicator">:</span>
      <span class="l l-Scalar l-Scalar-Plain">sigma</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">1, 2</span>
      <span class="l l-Scalar l-Scalar-Plain">.logic</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">n[1:3] * mu[1] * sigma, n[4,5] * mu[2] * sigma[1]</span>
</pre></div>
<p>Without <code>.logic</code>, DSC will exhaust all combinations of 5 values of <code>n</code>, 2 of <code>mu</code> and 2 of <code>sigma</code>, a total of 20 parallel jobs. The <code>.logic</code> here states that instead of 20 jobs, DSC will first run 3 values of <code>n</code> with <code>mu = 0</code> and 2 values of <code>sigma</code>, then run another 2 values of <code>n</code> with <code>mu = 1</code> and <code>sigma = 1</code>, which is a total of 8 jobs. Notice that parameter index slicing makes it possible to run a subset of parameter values.</p>
<h3 id=".alias-[optional]">.alias [optional]<a class="anchor-link" href="#.alias-[optional]">&#182;</a></h3><h4 id="For-executables">For executables<a class="anchor-link" href="#For-executables">&#182;</a></h4><p>When <code>.alias</code> appears outside <code>params</code>, it should has a one-to-one correspondence with <code>exec</code> entry. These alias will be used to name the columns of DSC output database. For example:</p>
<div class="highlight"><pre><span></span><span class="l l-Scalar l-Scalar-Plain">pi0_score</span><span class="p p-Indicator">:</span>
      <span class="l l-Scalar l-Scalar-Plain">exec</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">score.R</span>
      <span class="l l-Scalar l-Scalar-Plain">.alias</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">score_pi0</span>
      <span class="l l-Scalar l-Scalar-Plain">params</span><span class="p p-Indicator">:</span>
          <span class="l l-Scalar l-Scalar-Plain">...</span>
      <span class="l l-Scalar l-Scalar-Plain">return</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">result</span>
</pre></div>
<p>Without <code>.alias</code>, the output step name in DSC database for this DSC block will be <code>score.r</code>; with the alias the column name will be <code>score_pi0</code>. Here <code>.alias</code> is useful when the same <code>exec</code> is used in different blocks for different purposes (here it is used to evaluate score for <code>pi0</code> but it may also be used in another block evaluating another quantity).</p>
<p><code>.alias</code> can also be used along with <code>.logic</code> for <code>exec</code> to better name composite steps. For example:</p>
<div class="highlight"><pre><span></span><span class="l l-Scalar l-Scalar-Plain">simulate</span><span class="p p-Indicator">:</span>
  <span class="l l-Scalar l-Scalar-Plain">exec</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">BM.R, MultiBM.R, PostProcBM.py, PostProcMultiBM.py</span>
  <span class="l l-Scalar l-Scalar-Plain">.logic</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">exec[1] + exec[3], exec[2] + exec[4]</span>
  <span class="l l-Scalar l-Scalar-Plain">.alias</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">BM, MultiBM</span>
</pre></div>
<h4 id="For-parameters">For parameters<a class="anchor-link" href="#For-parameters">&#182;</a></h4><p><code>.alias</code> is often used to adjust parameter names for input to different executables. For example:</p>
<div class="highlight"><pre><span></span><span class="l l-Scalar l-Scalar-Plain">params</span><span class="p p-Indicator">:</span>
    <span class="l l-Scalar l-Scalar-Plain">mu</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">1, 2, 3</span>
    <span class="l l-Scalar l-Scalar-Plain">exec[2]</span><span class="p p-Indicator">:</span>
      <span class="l l-Scalar l-Scalar-Plain">.alias</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">theta = mu</span>
</pre></div>
<p>then all <code>exec</code> takes a parameter <code>mu</code>, except for <code>exec[2]</code> which requires parameter with name <code>theta</code>, but <code>theta</code> in <code>exec[2]</code> is equivalent to <code>mu</code> in other <code>exec</code>. Under the hood DSC will load values from <code>mu</code> and assign them to <code>theta</code> for use with <code>exec[2]</code>.</p>
<p>For plugins, <code>.alias</code> is often used with <a href="#pack">Pack</a> operator to consolidate parameters to a single data object (list for R, dictionary for Python).</p>
<h3 id=".options-[optional]">.options [optional]<a class="anchor-link" href="#.options-[optional]">&#182;</a></h3><p><em>FIXME: this feature is not yet implemented as of May 01, 2016.</em></p>
<p><code>.options</code> include parameters that controls behavior of the corresponding <code>exec</code> as it executes, for example:</p>
<div class="highlight"><pre><span></span><span class="c1"># .options: ncpu = 2, mem = 4G</span>
</pre></div>
<p>Supported options are:</p>
<ul>
<li><code>ncpu</code>: Number of required CPUs.</li>
<li><code>mem</code>: Required memory.</li>
<li><code>inline</code>: True or False, of whether or not an R script is executed inline with the next procedure instead of producing return files. This feature is useful when the cost of computation for a procedure is trivial compared to the cost of storing its output. For example if a simulation procedure is simply <code>runif(500000)</code> it makes more sense to save this line of code and execute it inline with the next step, rather than to save a vector of 500,000 random numbers to disk.</li>
</ul>
<h4 id="Scope-of-.logic,-.alias-and-.options">Scope of .logic, .alias and .options<a class="anchor-link" href="#Scope-of-.logic,-.alias-and-.options">&#182;</a></h4><p>When these parameters appear in <code>params</code> but outside any <code>exec[i]</code>, then they will also effect all parameters under <code>exec[i]</code> when applicable. However this behavior can be overloaded inside <code>exec[i]</code> if the same parameter is re-defined.</p>
<p><em>FIXME: example needed</em></p>
<h2 id="DSC-Block-Operators">DSC Block Operators<a class="anchor-link" href="#DSC-Block-Operators">&#182;</a></h2><h3 id="Sigils-$-and-$()">Sigils $ and $()<a class="anchor-link" href="#Sigils-$-and-$()">&#182;</a></h3><h4 id="$-in-exec-entry">$ in <code>exec</code> entry<a class="anchor-link" href="#$-in-exec-entry">&#182;</a></h4><p>In <code>exec</code>, <code>$</code> refers to parameters defined inside <code>params</code> of the same block.</p>
<h4 id="$-in-params-entries">$ in <code>params</code> entries<a class="anchor-link" href="#$-in-params-entries">&#182;</a></h4><p>In <code>params</code>, <code>$</code> refers to return values from an upstream block.</p>
<h4 id="$()">$()<a class="anchor-link" href="#$()">&#182;</a></h4><p><code>$()</code> refers to variables defined in <code>DSC::parameters</code>. For example:</p>
<div class="highlight"><pre><span></span><span class="l l-Scalar l-Scalar-Plain">simulate</span><span class="p p-Indicator">:</span>
      <span class="l l-Scalar l-Scalar-Plain">params</span><span class="p p-Indicator">:</span> 
         <span class="l l-Scalar l-Scalar-Plain">methods</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">$(data_functions)</span>
<span class=" -Error">  </span><span class="l l-Scalar l-Scalar-Plain">...</span>
  <span class="l l-Scalar l-Scalar-Plain">DSC</span><span class="p p-Indicator">:</span>
      <span class="l l-Scalar l-Scalar-Plain">...</span>
      <span class="l l-Scalar l-Scalar-Plain">parameters</span><span class="p p-Indicator">:</span>
          <span class="l l-Scalar l-Scalar-Plain">data_functions</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">mvngenotypes, discrete.cosine, discrete.cosine2, discrete.cosine.peaksel</span>
</pre></div>
<p>is equivalent to</p>
<div class="highlight"><pre><span></span><span class="l l-Scalar l-Scalar-Plain">simulate</span><span class="p p-Indicator">:</span>
      <span class="l l-Scalar l-Scalar-Plain">params</span><span class="p p-Indicator">:</span>
         <span class="l l-Scalar l-Scalar-Plain">methods</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">mvngenotypes, discrete.cosine, discrete.cosine2, discrete.cosine.peaksel</span>
</pre></div>
<h3 id="(),-the-group-operator">(), the group operator<a class="anchor-link" href="#(),-the-group-operator">&#182;</a></h3><p>A bare parenthesis groups parameters as one unit. For example:</p>
<div class="highlight"><pre><span></span><span class="l l-Scalar l-Scalar-Plain">exec</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">method.R, program.exe $K</span>
  <span class="l l-Scalar l-Scalar-Plain">params</span><span class="p p-Indicator">:</span>
     <span class="l l-Scalar l-Scalar-Plain">K</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">(1,2,3), (4,5,6)</span>
</pre></div>
<p>With <code>()</code>, <code>(1,2,3)</code> will be translated to vector assignment <code>c(1, 2, 3)</code> in R plugin, tuple <code>(1,2,3)</code> in Python plugin, or space separated argument sequence <code>program.exe 1 2 3</code> for the other command line program. Values will be assigned in units of 3 instead of separately.</p>
<h3 id="R(),-Python(),-Shell()">R(), Python(), Shell()<a class="anchor-link" href="#R(),-Python(),-Shell()">&#182;</a></h3><p>These operators run codes inside parenthesis using R, Python or Shell interpreters and evaluate the output. For example <code>seed: R(1:5)</code> results in <code>seed: 1, 2, 3, 4, 5</code>. This provides handy tool for generating input parameters.</p>
<h3 id="Combo(),-Pairs()">Combo(), Pairs()<a class="anchor-link" href="#Combo(),-Pairs()">&#182;</a></h3><p>Cartesian product and paired grouping of parameters. This can be considered short-cut for assigning values in DSC entries. For example:</p>
<div class="highlight"><pre><span></span><span class="l l-Scalar l-Scalar-Plain">exec</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">Combo(classifier.R (kernal_1, kernal_2, kernal_3))</span>
</pre></div>
<p>is equivalent to</p>
<div class="highlight"><pre><span></span><span class="l l-Scalar l-Scalar-Plain">exec</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">classifier.R kernal_1, classifier.R kernal_2, classifier.R kernal_3</span>
</pre></div>
<h3 id="Asis()">Asis()<a class="anchor-link" href="#Asis()">&#182;</a></h3><p>In DSC file, numeric vs. string data-types are automatically determined and there is no need to add quotes to strings. This is convenient in most cases but can be problematic when the input appear as strings but are in fact, for example, actual R codes that should not be converted to strings. <code>Asis()</code> operator will be useful for this case. For example,</p>
<div class="highlight"><pre><span></span><span class="l l-Scalar l-Scalar-Plain">g</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">Asis(normalmix(c(2/3,1/3),c(0,0),c(1,2)))</span>
</pre></div>
<p>will result in</p>
<div class="highlight"><pre><span></span>g <span class="o">=</span> normalmix<span class="p">(</span><span class="kt">c</span><span class="p">(</span><span class="m">2</span><span class="o">/</span><span class="m">3</span><span class="p">,</span><span class="m">1</span><span class="o">/</span><span class="m">3</span><span class="p">),</span><span class="kt">c</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="m">0</span><span class="p">),</span><span class="kt">c</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">2</span><span class="p">))</span>
</pre></div>
<p>But without <code>Asis()</code> it will read</p>
<div class="highlight"><pre><span></span>g <span class="o">=</span> <span class="s">&quot;normalmix(c(2/3,1/3),c(0,0),c(1,2))&quot;</span>
</pre></div>
<p><code>Asis()</code> can also be used to indicate a <em>raw string</em>, for example:</p>
<div class="highlight"><pre><span></span><span class="l l-Scalar l-Scalar-Plain">g</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">(1, 2, 3)</span>
  <span class="l l-Scalar l-Scalar-Plain">k</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">(&#39;1&#39;, &#39;2&#39;, &#39;3&#39;)</span>
  <span class="l l-Scalar l-Scalar-Plain">l</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">(Asis(&#39;1&#39;, &#39;2&#39;, &#39;3&#39;))</span>
</pre></div>
<p>will result in</p>
<div class="highlight"><pre><span></span>g <span class="o">=</span> <span class="kt">c</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">)</span>
  k <span class="o">=</span> <span class="kt">c</span><span class="p">(</span><span class="s">&#39;1&#39;</span><span class="p">,</span> <span class="s">&#39;2&#39;</span><span class="p">,</span> <span class="s">&#39;3&#39;</span><span class="p">)</span>
  l <span class="o">=</span> <span class="kt">c</span><span class="p">(</span><span class="s">&quot;&#39;1&#39;&quot;</span><span class="p">,</span> <span class="s">&quot;&#39;2&#39;&quot;</span><span class="p">,</span> <span class="s">&quot;&#39;3&#39;&quot;</span><span class="p">)</span>
</pre></div>
<h3 id="File()">File()<a class="anchor-link" href="#File()">&#182;</a></h3><p><em>FIXME: multiple extension and multiple return files are not yet implemented as of May 01, 2016.</em></p>
<p>When a DSC string parameter is a file name but the file is yet to be created (by the current computational step), it is required that <code>File()</code> operator be applied to the parameter to indicate that it represents a file / files although they do not yet exist . <code>File()</code> operator accepts file extension and will assign a unique basename for the context. For example:</p>
<div class="highlight"><pre><span></span><span class="l l-Scalar l-Scalar-Plain">params</span><span class="p p-Indicator">:</span>
          <span class="l l-Scalar l-Scalar-Plain">data</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">$sim</span>
          <span class="l l-Scalar l-Scalar-Plain">K</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">1, 2, 3, 4, 5</span>
          <span class="l l-Scalar l-Scalar-Plain">ped</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">File(ped, map)</span>
          <span class="l l-Scalar l-Scalar-Plain">score</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">File(score)</span>
<span class=" -Error">      </span><span class="l l-Scalar l-Scalar-Plain">return</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">score</span>
</pre></div>
<p>Here the return value <code>score</code> is a file, likely generated by the computational routine taking input <code>data</code> file and 5 values of parameter <code>K</code>. As a result, the returned <code>score</code> should be 5 files. Names of these 5 output <code>score</code> files will be automatically assigned, and users do not have to worry about file name specifications for different combinations of parameters. We allow for a simple interface to query the output files upon completion of DSC so that users can keep track of the outcome from particular sets of parameters.</p>
<p>When there are multiple suffix for example a pair of <code>(ped, map)</code>, then the resulting files are also in pairs, e.g., <code>dsc1.ped, dsc1.map</code>, ... <code>dsc5.ped, dsc5.map</code>.</p>
<p>Only files in <code>return</code> will be registered and saved. Other files are considered temporary and will not be monitored.</p>
<h3 id="Pack()">Pack()<a class="anchor-link" href="#Pack()">&#182;</a></h3><p><em>FIXME: partial conversion with Pack() is not yet implemented as of May 01, 2016.</em></p>
<p>This is used in <code>.alias</code> entries to help construct variables for plugin executables. For example for an R plugin</p>
<div class="highlight"><pre><span></span><span class="l l-Scalar l-Scalar-Plain">.alias</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">args = Pack()</span>
</pre></div>
<p>will convert all variables in corresponding parameter space, say <code>x,y,z</code> to <code>args = list(x = ..., y = ..., z = ...)</code>. Likewise, <code>Pack()</code> will convert parameters to <code>dictionary</code> in Python. Partial conversion is also supported, for example <code>args = Pack(x, y)</code> will only convert selected variables to R list, <code>args = list(x = x, y = y)</code>.</p>
<h3 id="Index-and-slicing">Index and slicing<a class="anchor-link" href="#Index-and-slicing">&#182;</a></h3><p>Index can be used in the following context:</p>
<ul>
<li>Index for parameters in <code>exec</code> entry, for example <code>exec: makeped.py $data $output[1]</code> where <code>output</code> parameter takes the form of <code>output: (1.ped, 1.map), (2.ped, 2.map)</code>.</li>
<li>Index for <code>exec</code> in <code>.logic</code> inside and outside <code>params</code>; each element corresponds to a computational routine in <code>exec</code></li>
<li>Index for parameters defined by <code>params</code> in <code>.logic</code> inside <code>params</code>; each element corresponds to a value for the parameter.</li>
<li>Index for block names in <code>DSC::run</code> sequence; each element corresponds to a computational routine in <code>exec</code>.</li>
</ul>
<p>Slicing syntax is allowed. For example, <code>n[1,2,4]</code> extracts the first, second and forth elements of <code>n</code>. <code>n[1:4]</code> extracts elements 1 though 4, and <code>n[1:9:2]</code> extracts elements 1, 3, 5, 7, 9.</p>
<h2 id="Block-Inheritance">Block Inheritance<a class="anchor-link" href="#Block-Inheritance">&#182;</a></h2><p>When a new block shares similar specifications with existing blocks, block inheritance is introduced to make new block definition more succinct. For example:</p>
<div class="highlight"><pre><span></span><span class="l l-Scalar l-Scalar-Plain">SVA</span><span class="p p-Indicator">:</span>
      <span class="l l-Scalar l-Scalar-Plain">exec</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">SVA.R</span>
      <span class="l l-Scalar l-Scalar-Plain">params</span><span class="p p-Indicator">:</span>
          <span class="l l-Scalar l-Scalar-Plain">data</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">$data</span>
          <span class="l l-Scalar l-Scalar-Plain">.alias</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">Pack(args)</span>
      <span class="l l-Scalar l-Scalar-Plain">return</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">data</span>

<span class=" -Error">  </span><span class="l l-Scalar l-Scalar-Plain">RUV(SVA)</span><span class="p p-Indicator">:</span>
      <span class="l l-Scalar l-Scalar-Plain">exec</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">RUV.R</span>

  <span class="l l-Scalar l-Scalar-Plain">voom(SVA)</span><span class="p p-Indicator">:</span>
      <span class="l l-Scalar l-Scalar-Plain">exec</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">voom.R</span>
</pre></div>
<p>Here, the 3 blocks differ only in the executable name. With block inheritance, we can completely configure <code>SVA</code>, then inherit it to configure "RUV" and "voom" where only <code>exec</code> have to be re-defined.</p>
<h2 id="DSC-Sequences">DSC Sequences<a class="anchor-link" href="#DSC-Sequences">&#182;</a></h2><p>Blocks are executed from the <strong>DSC</strong> section as <em>sequences</em>, defined by the <code>DSC::run</code> entry. Ways these blocks are connected can be specified via "*", "," and "()" operators:</p>
<p><em>FIXME: give example for</em> <code>+</code></p>
<ul>
<li>"*": right hand side (RHS) is executed after the left hand side (LHS).</li>
<li>"+": LHS and RHS are pair-wise combined first. <strong>In DSC, + operator has higher precedence than * operator</strong>.</li>
<li>",": RHS and LHS are concurrent.</li>
<li>"()": allows for combinations of "*" and ",".</li>
</ul>
<p>These operators also apply to <code>.logic</code> entries which define the ways parameters are combined.</p>
<h3 id="Example-1">Example 1<a class="anchor-link" href="#Example-1">&#182;</a></h3><div class="highlight"><pre><span></span><span class="l l-Scalar l-Scalar-Plain">run</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">simulate * (transform * estimate) * score</span>
</pre></div>
<p>DSC will run "transform" first, followed by "estimate".</p>
<h3 id="Example-2">Example 2<a class="anchor-link" href="#Example-2">&#182;</a></h3><div class="highlight"><pre><span></span><span class="l l-Scalar l-Scalar-Plain">run</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">simulate * (transform * estimate, estimate) * score</span>
</pre></div>
<p>DSC will run 2 concurrent sequences of steps. The first involves "transform" followed by "estimate"; the second is "estimate" only.</p>
<p>Slicing is supported, for example:</p>
<div class="highlight"><pre><span></span><span class="l l-Scalar l-Scalar-Plain">run</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">simulate * (transform[1:3] * estimate[1], transform[4:5] * estimate[2], estimate) * score</span>
</pre></div>
<h3 id="Example-3">Example 3<a class="anchor-link" href="#Example-3">&#182;</a></h3><div class="highlight"><pre><span></span><span class="l l-Scalar l-Scalar-Plain">run</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">simulate * (voom, sqrt, identity) * (RUV, SVA) * (DESeq, edgeRglm, ash) * score</span>
</pre></div>
<p>will be expanded to:</p>
<div class="highlight"><pre><span></span><span class="l l-Scalar l-Scalar-Plain">run</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">simulate * sqrt * RUV * DESeq * score,</span>
       <span class="l l-Scalar l-Scalar-Plain">simulate * sqrt * SVA * DESeq * score,</span>
       <span class="l l-Scalar l-Scalar-Plain">simulate * identity * RUV * DESeq * score,</span>
       <span class="l l-Scalar l-Scalar-Plain">simulate * voom * RUV * DESeq * score,</span>
       <span class="l l-Scalar l-Scalar-Plain">simulate * identity * SVA * DESeq * score,</span>
       <span class="l l-Scalar l-Scalar-Plain">simulate * voom * SVA * DESeq * score,</span>
       <span class="l l-Scalar l-Scalar-Plain">simulate * sqrt * RUV * ash * score,</span>
       <span class="l l-Scalar l-Scalar-Plain">simulate * sqrt * RUV * edgeRglm * score,</span>
       <span class="l l-Scalar l-Scalar-Plain">simulate * sqrt * SVA * ash * score,</span>
       <span class="l l-Scalar l-Scalar-Plain">simulate * sqrt * SVA * edgeRglm * score,</span>
       <span class="l l-Scalar l-Scalar-Plain">simulate * identity * RUV * ash * score,</span>
       <span class="l l-Scalar l-Scalar-Plain">simulate * voom * RUV * ash * score,</span>
       <span class="l l-Scalar l-Scalar-Plain">simulate * identity * RUV * edgeRglm * score,</span>
       <span class="l l-Scalar l-Scalar-Plain">simulate * voom * RUV * edgeRglm * score,</span>
       <span class="l l-Scalar l-Scalar-Plain">simulate * identity * SVA * ash * score,</span>
       <span class="l l-Scalar l-Scalar-Plain">simulate * voom * SVA * ash * score,</span>
       <span class="l l-Scalar l-Scalar-Plain">simulate * identity * SVA * edgeRglm * score,</span>
       <span class="l l-Scalar l-Scalar-Plain">simulate * voom * SVA * edgeRglm * score</span>
</pre></div>
<h2 id="DSC-Section-Parameters">DSC Section Parameters<a class="anchor-link" href="#DSC-Section-Parameters">&#182;</a></h2><ul>
<li><code>master</code>: Block names that will become one of the <em>master</em> tables in DSC output. By default the last block of a DSC sequence will be the master table. When a block becomes a master table, DSC will attempt to extract information from the block output and write them explicitly to the DSC output database.</li>
<li><code>parameters</code>: Defines DSC variables which can be used anywhere in the DSC file through <code>$()</code> sigil.</li>
<li><code>exec_path</code>: Search path for executable files.</li>
<li><code>lib_path</code>: Search path for library files, such as R script to be <code>source</code>-ed or Python scripts to be <code>import</code>-ed.</li>
<li><code>R_libs</code>: Required R libraries, from cran, bioconductor or github:<ul>
<li><code>package</code>: DSC will check / install <code>package</code> from cran or bioconductor.</li>
<li><code>github_repo/package</code>: DSC will install <code>package</code> from <code>github_repo</code> on github.</li>
<li><code>package (version[s])</code>: DSC will install <code>package</code> and check version as required. A warning message will be generated if version do not match. It is possible to specify several versions such as <code>edgeR (3.12.0, 3.12.1)</code> or simply <code>edgeR (3.12.0+)</code>.</li>
</ul>
</li>
<li><code>work_dir</code>: work directory where DSC runs take place.</li>
</ul>

</div>
</div>
</div>
    </div>
  </div>
</body>
</html>
