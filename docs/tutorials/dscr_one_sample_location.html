<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>One sample location estimation; DSCR example</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<!--
%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{A Simple Example: Evaluating Mean-Estimation Methods}
-->

<h1>One sample location estimation; DSCR example</h1>

<p>This vignette is designed to illustrate the (in development) dscr package for Dynamic Statistical Comparisons in R.</p>

<p>We&#39;ll do a simulation study to assess methods for estimating the mean of a distribution. 
The simulations will be performed under 
three scenarios: a normal distribution, a uniform distribution
and a Cauchy (t distribution on 1df). And we&#39;ll compare three methods: 
sample mean, sample median and the Winsorized mean (from the psych package). </p>

<p>First load the library, and initialize a new &ldquo;dsc&rdquo; using new_dsc.
This object will be used to store the details of the dsc.</p>

<pre><code class="r">library(dscr)
#  install_github(repo=&quot;stephens999/dscr&quot;)
dsc_osl = new_dsc(&quot;one_sample_location&quot;,&quot;one_samp_loc&quot;)
</code></pre>

<p>Now define the function to create data, which consists of input, and meta-data. 
The input is what the methods will be given. The meta data will be used
when scoring the methods. So here, the input is a random sample, and the meta-data is the true mean (0). </p>

<p>This function can take a single parameter args, which is a list. In this case we use args to pass number of samples and the type distribution to be simulated from.</p>

<pre><code class="r">datamaker = function(args){

  nsamp=args$nsamp
  disttype=args$disttype

  #here is the meat of the function that needs to be defined for each dsc to be done
  if(disttype==&quot;normal&quot;){
    input = list(x=rnorm(nsamp,0,1))
    meta =  list(truemean=0)
  }

  if(disttype==&quot;uniform&quot;){
    input = list(x=runif(nsamp,-1,1))
    meta = list(truemean=0)
  }

  if(disttype==&quot;Cauchy&quot;){
    input = list(x=rt(nsamp,df=1))
    meta = list(truemean=0)
  }
  #end of meat of function

  data = list(meta=meta,input=input)

  return(data)
}
</code></pre>

<p>Now define the scenarios that use this datamaker. Each scenario is determined by the datamaker,
its arguments, and the seeds it uses. (Maybe the list of seeds should not be part of the scenario definition - I&#39;m not sure). Each scenario also has a name which is used for naming the scenario in results and also output directories - so use something that is a valid filename. </p>

<pre><code class="r">add_scenario(dsc_osl,name=&quot;normal&quot;,datamaker,args=list(disttype=&quot;normal&quot;,nsamp=1000),seed=1:100)
add_scenario(dsc_osl,name=&quot;uniform&quot;,datamaker,args=list(disttype=&quot;uniform&quot;,nsamp=1000),seed=1:100)
add_scenario(dsc_osl,name=&quot;Cauchy&quot;,datamaker,args=list(disttype=&quot;Cauchy&quot;,nsamp=1000),seed=1:100)
</code></pre>

<p>Now define the methods.
They have to have the form where they take &ldquo;input&rdquo; and produce &ldquo;output&rdquo;
in a specified format. In this case the input format is a list with one component (x).
The output format is a list with one component (meanest), the estimated mean. </p>

<p>Effectively we have to write a &ldquo;wrapper&rdquo; function for each of our three methods
that makes sure that they conform to this input-output requirement. (Note that the
winsor.wrapper function makes use of the function winsor.mean from the psych package.)
Note that we allow for additional arguments ot each function, but don&#39;t use them here.</p>

<pre><code class="r">mean.wrapper = function(input,args){
  return(list(meanest = mean(input$x)))  
}

median.wrapper = function(input,args){
  return(list(meanest = median(input$x)))    
}

winsor.wrapper = function(input,args){
  return(list(meanest = psych::winsor.mean(input$x,trim=0.2)))
}
</code></pre>

<p>Now define a list of the methods we&#39;ll use. 
Each method is defined by its name, the function used to implement it, and any additional arguments (none here):</p>

<pre><code class="r">  add_method(dsc_osl,name=&quot;mean&quot;,fn =mean.wrapper,args=NULL)
  add_method(dsc_osl,name=&quot;median&quot;,fn=median.wrapper,args=NULL)
  add_method(dsc_osl,name=&quot;winsor&quot;,fn=winsor.wrapper,args=NULL)
</code></pre>

<p>And define a score function that says how well a method has done. Here we&#39;ll use squared error
and absolute error:</p>

<pre><code class="r">score = function(data, output){
  return(list(squared_error = (data$meta$truemean-output$meanest)^2, abs_error = abs(data$meta$truemean-output$meanest)))
}
  add_score(dsc_osl,score)
</code></pre>

<p>Now we&#39;ll run all the methods on all the scenarios:</p>

<pre><code class="r">  res=run_dsc(dsc_osl)
</code></pre>

<p>This returns a dataframe with the results of running all the methods on all the scenarios:</p>

<pre><code class="r">  head(res)
</code></pre>

<pre><code>##      .id seed scenario method squared_error   abs_error user.self sys.self
## 1 normal    1   normal   mean  1.356792e-04 0.011648142         0        0
## 2 normal    2   normal   mean  3.843843e-03 0.061998736         0        0
## 3 normal    3   normal   mean  4.091567e-05 0.006396535         0        0
## 4 normal    4   normal   mean  1.185285e-03 0.034427966         0        0
## 5 normal    5   normal   mean  3.027412e-04 0.017399459         0        0
## 6 normal    6   normal   mean  6.387521e-04 0.025273546         0        0
##   elapsed user.child sys.child
## 1       0          0         0
## 2       0          0         0
## 3       0          0         0
## 4       0          0         0
## 5       0          0         0
## 6       0          0         0
</code></pre>

<p>And we can summarize the results (eg mean squared error) using the aggregate function</p>

<pre><code class="r">  aggregate(abs_error~method+scenario,res,mean)
</code></pre>

<pre><code>##   method scenario  abs_error
## 1   mean   Cauchy 1.57503809
## 2 median   Cauchy 0.04001257
## 3 winsor   Cauchy 0.05056598
## 4   mean   normal 0.02723692
## 5 median   normal 0.03276252
## 6 winsor   normal 0.02801455
## 7   mean  uniform 0.01434410
## 8 median  uniform 0.02357357
## 9 winsor  uniform 0.01739025
</code></pre>

<pre><code class="r">  aggregate(squared_error~method+scenario,res,mean)
</code></pre>

<pre><code>##   method scenario squared_error
## 1   mean   Cauchy  1.082254e+01
## 2 median   Cauchy  2.752190e-03
## 3 winsor   Cauchy  4.545666e-03
## 4   mean   normal  1.128859e-03
## 5 median   normal  1.609965e-03
## 6 winsor   normal  1.213718e-03
## 7   mean  uniform  2.922071e-04
## 8 median  uniform  7.871420e-04
## 9 winsor  uniform  4.371870e-04
</code></pre>

<p>Now suppose we are coming in and want to add a method, say the trimmed mean, to the comparison.
Suppose also we want to try out the trimmed mean with two different settings of the trim argument. 
Here is what we do (note that the different settings of the argument are treated as different methods, but the two methods use the same fn)</p>

<pre><code class="r">  trimmedmean.wrapper = function(input,args){
    return(list(meanest=mean(input$x,trim=args$trim)))
  }

  add_method(dsc_osl,name=&quot;trimmedmean1&quot;,fn = trimmedmean.wrapper,args=list(trim=0.2))
  add_method(dsc_osl,name=&quot;trimmedmean2&quot;,fn = trimmedmean.wrapper,args=list(trim=0.4))
  res=run_dsc(dsc_osl)
</code></pre>

<pre><code class="r">  aggregate(abs_error~method+scenario,res,mean)
</code></pre>

<pre><code>##          method scenario  abs_error
## 1          mean   Cauchy 1.57503809
## 2        median   Cauchy 0.04001257
## 3  trimmedmean1   Cauchy 0.04126206
## 4  trimmedmean2   Cauchy 0.03925086
## 5        winsor   Cauchy 0.05056598
## 6          mean   normal 0.02723692
## 7        median   normal 0.03276252
## 8  trimmedmean1   normal 0.02847477
## 9  trimmedmean2   normal 0.02944465
## 10       winsor   normal 0.02801455
## 11         mean  uniform 0.01434410
## 12       median  uniform 0.02357357
## 13 trimmedmean1  uniform 0.01922955
## 14 trimmedmean2  uniform 0.02201650
## 15       winsor  uniform 0.01739025
</code></pre>

<pre><code class="r">  aggregate(squared_error~method+scenario,res,mean)
</code></pre>

<pre><code>##          method scenario squared_error
## 1          mean   Cauchy  1.082254e+01
## 2        median   Cauchy  2.752190e-03
## 3  trimmedmean1   Cauchy  3.041337e-03
## 4  trimmedmean2   Cauchy  2.570032e-03
## 5        winsor   Cauchy  4.545666e-03
## 6          mean   normal  1.128859e-03
## 7        median   normal  1.609965e-03
## 8  trimmedmean1   normal  1.230613e-03
## 9  trimmedmean2   normal  1.339422e-03
## 10       winsor   normal  1.213718e-03
## 11         mean  uniform  2.922071e-04
## 12       median  uniform  7.871420e-04
## 13 trimmedmean1  uniform  5.299378e-04
## 14 trimmedmean2  uniform  7.128600e-04
## 15       winsor  uniform  4.371870e-04
</code></pre>

<p>Note that at present run_dsc does not recreate any files that are already there.
Thus in this case it is only running the new methods (trimmedmean1 and trimmedmean2)- the results for
other methods are already there. If you want to force it to recreate the files then you need
to delete them manually before running run_dsc. You can do this from with R using the functions <code>reset_dsc()</code> to remove all the results, or <code>reset_scenario</code>   or <code>reset_method</code>
to remove results only for a particular method or scenario.</p>

<p>I will note that it is possible within run_dsc to specify to run the dsc on only a subset of the methods and scenarios</p>

<pre><code class="r">  res = run_dsc(dsc_osl, c(&quot;Cauchy&quot;,&quot;normal&quot;),c(&quot;trimmedmean1&quot;))
</code></pre>

<pre><code class="r">  aggregate(abs_error~method+scenario,res,mean)
</code></pre>

<pre><code>##         method scenario  abs_error
## 1 trimmedmean1   Cauchy 0.04126206
## 2 trimmedmean1   normal 0.02847477
</code></pre>

<pre><code class="r">  aggregate(squared_error~method+scenario,res,mean)
</code></pre>

<pre><code>##         method scenario squared_error
## 1 trimmedmean1   Cauchy   0.003041337
## 2 trimmedmean1   normal   0.001230613
</code></pre>

<p>Finally, dscr has the ability to add a method that can &ldquo;cheat&rdquo; by taking not only the input data, but also the meta data. Sometimes this can be useful
to allow implementation of a &ldquo;gold standard&rdquo; method against which other methods can be compared (even if the gold standard is not achievable in practice). In this case the method &ldquo;truth&rdquo; trivially cheats by passing back the truth as its estimate! This is of course just for illustration - in practice the gold standard method would usually be more subtle than this.
For instance a gold standard method might perform (in some sense optimal) inference under the model used to simulate the data&hellip;</p>

<pre><code class="r">  #define a wrapper function that takes both input and meta for its arguments
  truth.wrapper = function(input,meta,args){
    return(list(meanest = meta$truemean))
  }
  #indicate that this is a gold standard method by passing a gold_flag=TRUE
  add_method(dsc_osl,&quot;truth&quot;,truth.wrapper,gold_flag=TRUE)
</code></pre>

<p>Then we can re-run the dsc:</p>

<pre><code class="r">  res=run_dsc(dsc_osl)
</code></pre>

<pre><code class="r">  aggregate(abs_error~method+scenario,res,mean)
</code></pre>

<pre><code>##          method scenario  abs_error
## 1          mean   Cauchy 1.57503809
## 2        median   Cauchy 0.04001257
## 3  trimmedmean1   Cauchy 0.04126206
## 4  trimmedmean2   Cauchy 0.03925086
## 5         truth   Cauchy 0.00000000
## 6        winsor   Cauchy 0.05056598
## 7          mean   normal 0.02723692
## 8        median   normal 0.03276252
## 9  trimmedmean1   normal 0.02847477
## 10 trimmedmean2   normal 0.02944465
## 11        truth   normal 0.00000000
## 12       winsor   normal 0.02801455
## 13         mean  uniform 0.01434410
## 14       median  uniform 0.02357357
## 15 trimmedmean1  uniform 0.01922955
## 16 trimmedmean2  uniform 0.02201650
## 17        truth  uniform 0.00000000
## 18       winsor  uniform 0.01739025
</code></pre>

<pre><code class="r">  aggregate(squared_error~method+scenario,res,mean)
</code></pre>

<pre><code>##          method scenario squared_error
## 1          mean   Cauchy  1.082254e+01
## 2        median   Cauchy  2.752190e-03
## 3  trimmedmean1   Cauchy  3.041337e-03
## 4  trimmedmean2   Cauchy  2.570032e-03
## 5         truth   Cauchy  0.000000e+00
## 6        winsor   Cauchy  4.545666e-03
## 7          mean   normal  1.128859e-03
## 8        median   normal  1.609965e-03
## 9  trimmedmean1   normal  1.230613e-03
## 10 trimmedmean2   normal  1.339422e-03
## 11        truth   normal  0.000000e+00
## 12       winsor   normal  1.213718e-03
## 13         mean  uniform  2.922071e-04
## 14       median  uniform  7.871420e-04
## 15 trimmedmean1  uniform  5.299378e-04
## 16 trimmedmean2  uniform  7.128600e-04
## 17        truth  uniform  0.000000e+00
## 18       winsor  uniform  4.371870e-04
</code></pre>

</body>

</html>
