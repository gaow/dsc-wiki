
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="ipynb_website:version" content="0.9.4" />
<meta name="viewport" content="width=device-width, initial-scale=1" />

<link rel="stylesheet" type="text/css" href="../css/jt.css">

<link rel="stylesheet" type="text/css" href="../css/toc2.css">

<link href="../site_libs/jqueryui-1.11.4/jquery-ui.css">
<link rel="stylesheet" href="../site_libs/bootstrap-3.3.5/css/cosmo.min.css" rel="stylesheet" />
<link rel="stylesheet" href="../site_libs/font-awesome-4.5.0/css/font-awesome.min.css" rel="stylesheet" />
<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.9.1/jquery-ui.min.js"></script>
<script src="../site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="../site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="../site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>

<link rel="stylesheet"
      href="../site_libs/highlightjs-1.1/textmate.css"
      type="text/css" />

<script src="../site_libs/highlightjs-1.1/highlight.js"></script>
<script type="text/javascript">
if (window.hljs && document.readyState && document.readyState === "complete") {
   window.setTimeout(function() {
      hljs.initHighlighting();
   }, 0);
}
</script>

<script src="../js/doc_toc.js"></script>
<script src="../js/docs.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script>
    MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true
        },
        "HTML-CSS": {
            preferredFont: "TeX",
            availableFonts: ["TeX"],
            styles: {
                scale: 110,
                ".MathJax_Display": {
                    "font-size": "110%",
                }
            }
        }
    });
</script>
<script>
function filterDataFrame(id) {
    var input = document.getElementById("search_" + id);
    var filter = input.value.toUpperCase();
    var table = document.getElementById("dataframe_" + id);
    var tr = table.getElementsByTagName("tr");
    // Loop through all table rows, and hide those who don't match the search query
    for (var i = 1; i < tr.length; i++) {
        for (var j = 0; j < tr[i].cells.length; ++j) {
            var matched = false;
            if (tr[i].cells[j].innerHTML.toUpperCase().indexOf(filter) != -1) {
                tr[i].style.display = "";
                matched = true
                break;
            }
            if (!matched)
                tr[i].style.display = "none";
        }
    }
}
function sortDataFrame(id, n, dtype) {
    var table = document.getElementById("dataframe_" + id);
    var tb = table.tBodies[0]; // use `<tbody>` to ignore `<thead>` and `<tfoot>` rows
    var tr = Array.prototype.slice.call(tb.rows, 0); // put rows into array
    if (dtype === 'numeric') {
        var fn = function(a, b) { 
            return parseFloat(a.cells[n].textContent) <= parseFloat(b.cells[n].textContent) ? -1 : 1;
        }
    } else {
        var fn = function(a, b) {
            var c = a.cells[n].textContent.trim().localeCompare(b.cells[n].textContent.trim()); 
            return c > 0 ? 1 : (c < 0 ? -1 : 0) }
    }
    var isSorted = function(array, fn) {
        if (array.length < 2)
            return 1;
        var direction = fn(array[0], array[1]); 
        for (var i = 1; i < array.length - 1; ++i) {
            var d = fn(array[i], array[i+1]);
            if (d == 0)
                continue;
            else if (direction == 0)
                direction = d;
            else if (direction != d)
                return 0;
            }
        return direction;
    }
    var sorted = isSorted(tr, fn);
    if (sorted == 1 || sorted == -1) {
        // if sorted already, reverse it
        for(var i = tr.length - 1; i >= 0; --i)
            tb.appendChild(tr[i]); // append each row in order
    } else {
        tr = tr.sort(fn);
        for(var i = 0; i < tr.length; ++i)
            tb.appendChild(tr[i]); // append each row in order
    }
}
</script>

<script>
$( document ).ready(function(){
            var cfg={'threshold':3,     // depth of toc (number of levels)
             'number_sections': false,
             'toc_cell': false,          // useless here
             'toc_window_display': true, // display the toc window
             "toc_section_display": "block", // display toc contents in the window
             'sideBar':true,       // sidebar or floating window
             'navigate_menu':false       // navigation menu (only in liveNotebook -- do not change)
            }
            var st={};                  // some variables used in the script
            st.rendering_toc_cell = false;
            st.config_loaded = false;
            st.extension_initialized=false;
            st.nbcontainer_marginleft = $('#notebook-container').css('margin-left')
            st.nbcontainer_marginright = $('#notebook-container').css('margin-right')
            st.nbcontainer_width = $('#notebook-container').css('width')
            st.oldTocHeight = undefined
            st.cell_toc = undefined;
            st.toc_index=0;
            // fire the main function with these parameters
            table_of_contents(cfg, st);
            var file=tutorialsDict[$("h1:first").attr("id")];
            $("#toc-level0 a").css("color","#126dce");
            $('a[href="#'+$("h1:first").attr("id")+'"]').hide()
            var docs=tutorialsArray;
            var docs_map=tutorialsArrayMap;
            var pos=tutorialsArray.indexOf(file);
            for (var a=pos;a>=0;a--){
                  $('<li><a href="'+docs[a]+'.html"><font color="#073642"><b>'+docs_map[docs[a]].replace(/_/g," ")+'</b></font></a></li>').insertBefore("#toc-level0 li:eq(0)");
            }
            $('a[href="'+file+'.html'+'"]').css("color","#126dce");
            for (var a=pos+1;a<docs.length;a++){
                  $(".toc #toc-level0").append('<li><a href="'+docs[a]+'.html"><font color="#073642"><b>'+docs_map[docs[a]].replace(/_/g," ")+'</b></font></a></li>');
            }
            // $("#toc-header").hide(); // comment out because it prevents search bar from displaying
    });
</script>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');
  // mark it active
  menuAnchor.parent().addClass('active');
  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>
<div class="container-fluid main-container">
<!-- tabsets -->
<script src="../site_libs/navigation-1.1/tabsets.js"></script>
<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});
</script>



<title>Dynamic Statistical Comparisons</title>

<style type = "text/css">
body {
  font-family: "Droid Sans";
  padding-top: 66px;
  padding-bottom: 40px;
}
</style>
</head>

<body>
<div tabindex="-1" id="notebook" class="border-box-sizing">
<div class="container" id="notebook-container">

<!-- code folding -->

<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="../index.html">Dynamic Statistical Comparisons</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        
<li>
  <a href="../index.html">Home</a>
</li>
        
<li>
  <a href="../tutorials.html">Tutorials</a>
</li>
        
<li>
  <a href="../installation.html">Installation</a>
</li>
        
<li>
  <a href="../examples.html">Examples</a>
</li>
        
<li>
  <a href="../manual.html">Manual</a>
</li>
        
      </ul>
        
<ul class="nav navbar-nav navbar-right">
<li>
   <a href="https://github.com/stephenslab/dsc2"> <span class="fa fa-github"></span> </a>
</li>
</ul>
        
      </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Introduction-to-DSC-(Part-II)">Introduction to DSC (Part II)<a class="anchor-link" href="#Introduction-to-DSC-(Part-II)">&#182;</a></h1><p>This is a continuation of the <a href="First_Course.html">Introduction to DSC (Part I)</a>. Here we use the example from that introduction to
illustrate three key concepts of DSC: "modules", "groups" and "pipeline variables". More advanced concepts will be introduced in <a href="">Part III</a>.</p>
<p>Material used in this example are in <a href="https://github.com/stephenslab/dsc/tree/master/vignettes/one_sample_location">the DSC vignettes repo</a>.</p>
<h2 id="Module-input/output;-pipeline-variables">Module input/output; pipeline variables<a class="anchor-link" href="#Module-input/output;-pipeline-variables">&#182;</a></h2><p>In DSC, information is passed from module to module
through "pipeline variables", which are indicated by using a name that begins with <code>$</code> (for example <code>$data</code>).
Under the hood DSC keeps track of pipeline variable values by saving
them in files. Specifically, when a module outputs a pipeline variable, its value is saved in a file; and when a module inputs a pipeline variable its value is read from a file. The values of pipeline variables can also be retrieved from these files after the DSC is run.</p>
<h3 id="Planning-a-DSC-file">Planning a DSC file<a class="anchor-link" href="#Planning-a-DSC-file">&#182;</a></h3><p>DSC is intended to help make benchmarks easier to read, maintain and extend. To achieve this it will be helpful
to start by doing some planning before writing a DSC file.</p>
<p>We suggesting starting the plan by identifying the <em>types of module</em> and the <em>pipeline variables</em> (i.e. the quantities being passed from module to module).
Pipeline variables should be given an informative name which must begin with a <code>$</code>. It may also be helpful to give names to the types of module.
(Note: names in DSC cannot have <code>.</code> character, which is reserved for another use.)</p>
<p>Recall that our example benchmark compares methods for estimating a population mean from a simulated sample, and follows the simple <code>simulate</code>-<code>analyze</code>-<code>score</code> design.
There are three different types of module:</p>
<ul>
<li>a <code>simulate</code> module outputs a vector of simulated data (<code>$data</code>),  and the value of the population mean used to simulate it (<code>$true_mean</code>).</li>
<li>an <code>analyze</code> module inputs <code>$data</code> and outputs an estimate (<code>$est_mean</code>) of the population mean.</li>
<li>a <code>score</code> module inputs <code>$est_mean</code> and <code>$true_mean</code> and output a measure of the error (<code>$error</code>).</li>
</ul>
<p>Our DSC therefore has four pipeline variables: <code>$data</code>,<code>$true_mean</code>,<code>$est_mean</code> and <code>$error</code>.</p>
<p>This information is summarized in comments at the top of the DSC file (the <code>#</code> character indicates a comment in a DSC file; anything after a <code>#</code> is ignored by DSC.)</p>

<pre><code># Pipeline variables
#
# $data: vector of simulated data
# $true_mean: scalar value of the population mean used to simulate $data
# $est_mean:  scalar estimated value of the population mean
# $error: scalar measure of the accuracy of the estimate
#
#
# Module types
#
# simulate: . -&gt; $data, $true_mean
# analyze: $data -&gt; $est_mean
# score: $est_mean, $true_mean -&gt; $error</code></pre>
<h3 id="Notes-on-pipeline-variables">Notes on pipeline variables<a class="anchor-link" href="#Notes-on-pipeline-variables">&#182;</a></h3><ol>
<li><p>The pipeline variables output by a module are exactly the parts of the module output that are saved (in a file) for future use. So <code>$error</code> is here considered a pipeline variable because we want it saved at the end of the pipeline.</p>
</li>
<li><p>The pipeline variables are the only way that modules can communicate with one another. So if a module requires access to a piece of information generated by a previous module then this must be a pipeline variable. For example, a <code>score</code> module  naturally requires access to the true mean used to generate the data, so here this is output, as a pipeline variable, from a <code>simulate</code> module.</p>
</li>
</ol>
<h2 id="Specifying-modules-in-DSC-file">Specifying modules in DSC file<a class="anchor-link" href="#Specifying-modules-in-DSC-file">&#182;</a></h2><p>At its simplest, a DSC module definition
consists of a name,  a script (code)
implementing the module, and details of how pipeline variables are to be
passed in and out of the script.</p>
<p>Here we illustrate the syntax by explaining each module in our example.</p>
<h3 id="The-normal-module">The <code>normal</code> module<a class="anchor-link" href="#The-normal-module">&#182;</a></h3><p>The first module defined in the DSC file is the <code>normal</code> module:</p>

<pre><code>normal: R( x = rnorm(100,0,1) )
  $data: x
  $true_mean: 0</code></pre>
<p>The syntax tells DSC three things:</p>
<ul>
<li>a name for the module (<code>normal</code>)</li>
<li>an R script containing the code for the module. Here <code>R()</code> tells DSC that this code is an R script. For longer scripts this would be replaced with a filename of the file containing the script. We refer to variables in scripts like this as "script variables", so here <code>x</code> is a script variable.</li>
<li>how to determine the values of the pipeline variables <code>$data</code> and <code>$true_mean</code> after running the script. Here we want <code>$data</code> to take the value of the script variable <code>x</code>, and <code>$true_mean</code> is 0.</li>
</ul>
<h3 id="The-t-module">The <code>t</code> module<a class="anchor-link" href="#The-t-module">&#182;</a></h3><p>The <code>t</code> module is similar to the <code>normal</code> module, but
 generates 100 observations from a $t$ distribution with mean 3 and degrees of freedom 2.
Here is the specification:</p>

<pre><code>t: R( 3 + rt(100, df=2) )
  $data: x
  $true_mean: 3</code></pre>
<h3 id="Two-analyze-modules">Two <code>analyze</code> modules<a class="anchor-link" href="#Two-analyze-modules">&#182;</a></h3><p>Our example has two <code>analyze</code> modules: <code>mean</code> estimates the distribution mean by the sample mean; and <code>median</code> estimates the distribution mean by the sample median.
They are defined in the DSC file as follows:</p>

<pre><code>mean: R( y = mean(x) )
  x: $data
  $est_mean: y

median: R( y = median(x) )
  x: $data
  $est_mean: y</code></pre>
<p>These modules differ from the <code>simulate</code> modules in that they have both input and output.
Specifically:</p>
<ul>
<li><p>The syntax <code>x: $data</code> specifies a module input. It tells DSC that, before running the script, it should set the script variable <code>x</code> to the value of the pipeline variable <code>$data</code> (which means the value of <code>$data</code> output by the most recent previous module that output <code>$data</code>).</p>
</li>
<li><p>The syntax <code>$est_mean: y</code> specifies a module output. It tells DSC that after running the script it should set the value of the pipeline variable <code>$est_mean</code> to the value of the script variable <code>y</code> (similar to the <code>simulate</code> modules)</p>
</li>
</ul>
<p>Note that although the scripts in <code>normal</code>,<code>t</code>,<code>median</code> and <code>mean</code> all use a script variable <code>x</code>, these variables are logically distinct, and we must use a pipeline variable
(here <code>$data</code>) to pass the information on <code>x</code> from one script to another. Information can
flow from one module to another only through pipeline variables.</p>
<h3 id="Two-score-modules">Two <code>score</code> modules<a class="anchor-link" href="#Two-score-modules">&#182;</a></h3><p>Finally we create two <code>score</code> modules, one based on squared error (<code>sq_err</code>) and one based on absolute error (<code>abs_err</code>):</p>

<pre><code>sq_err: R( e = (a-b)^2 )
  a: $est_mean
  b: $true_mean
  $error: e

abs_err: R( e = abs(a-b) )
  a: $est_mean
  b: $true_mean
  $error: e</code></pre>
<h2 id="Defining-groups-and-pipelines">Defining groups and pipelines<a class="anchor-link" href="#Defining-groups-and-pipelines">&#182;</a></h2><p>The final stage is to tell DSC how to combine these
six modules into pipelines. We do this by
first defining the "groups" of similar modules, and then
defining pipelines in terms of these groups.</p>

<pre><code>DSC:
    define:
      simulate: normal, t
      analyze: mean, median
      score: abs_err, sq_err
    run: simulate * analyze * score
    output: dsc_result</code></pre>
<p>Here:</p>
<ul>
<li><code>DSC</code> is a keyword to indicate that here we are defining groups and pipelines (not a module definition).</li>
<li><code>define</code> is a keyword to indicate we are defining groups.
(here <code>simulate</code>, <code>analyze</code> and <code>score</code>).</li>
<li><code>run</code> is a keyword to indicate that we are defining the pipelines to be run. The <code>A * B</code> notation means to create all possible sequences of modules from groups <code>A</code> and <code>B</code>. That is, all sequences of the form <code>a</code>-<code>b</code> where <code>a</code> is a module in group <code>A</code> and <code>b</code> is a module in a group <code>B</code>. So here
<code>simulate * analyze * score</code> generates all pipelines that consist of first a module from the <code>simulate</code> group (<code>normal</code> or <code>t</code>), then a module from <code>analyze</code> (<code>mean</code> or <code>median</code>) and then a module from the <code>score</code> group (<code>sq_err</code> or <code>abs_err</code>).</li>
<li><code>output</code> tells DSC where to save results.</li>
</ul>
<!----
You can think of a pipeline variable
as a variable whose value may change as a pipeline is run. For example, in a pipeline `a-b-c`, with modules `a`, `b` and `c`,
if module `a` outputs a pipeline variable `$data`, and
then module `b` outputs `$data` with a new value,
then if module `c` inputs `$data` its value
will be the one output by `b` and not the one output by `a`.
---->
</div>
</div>
</div>
<hr>
Copyright (c) 2016-2018 <a href="http://home.uchicago.edu/gaow">Gao Wang</a>, <a href="http://stephenslab.uchicago.edu">Matthew Stephens</a>, <a href="https://pcarbo.github.io">Peter Carbonetto</a> and contributors.<br>&nbsp;&nbsp;&nbsp; Except where otherwise noted, this website is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.

</div>
</div>
</body>
</html>
