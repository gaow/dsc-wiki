
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="ipynb_website:version" content="0.9.4" />
<meta name="viewport" content="width=device-width, initial-scale=1" />

<link rel="stylesheet" type="text/css" href="../css/jt.css">

<link rel="stylesheet" type="text/css" href="../css/toc2.css">

<link href="../site_libs/jqueryui-1.11.4/jquery-ui.css">
<link rel="stylesheet" href="../site_libs/bootstrap-3.3.5/css/cosmo.min.css" rel="stylesheet" />
<link rel="stylesheet" href="../site_libs/font-awesome-4.5.0/css/font-awesome.min.css" rel="stylesheet" />
<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.9.1/jquery-ui.min.js"></script>
<script src="../site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="../site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="../site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>

<link rel="stylesheet"
      href="../site_libs/highlightjs/jnbinder.min.css"
      type="text/css" />

<script src="../site_libs/highlightjs/highlight.dsc.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
if (window.hljs && document.readyState && document.readyState === "complete") {
   window.setTimeout(function() {
      hljs.initHighlighting();
   }, 0);
}
</script>

<script src="../js/doc_toc.js"></script>
<script src="../js/docs.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script>
    MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true
        },
        "HTML-CSS": {
            preferredFont: "TeX",
            availableFonts: ["TeX"],
            styles: {
                scale: 110,
                ".MathJax_Display": {
                    "font-size": "110%",
                }
            }
        }
    });
</script>
<script>
function filterDataFrame(id) {
    var input = document.getElementById("search_" + id);
    var filter = input.value.toUpperCase();
    var table = document.getElementById("dataframe_" + id);
    var tr = table.getElementsByTagName("tr");
    // Loop through all table rows, and hide those who don't match the search query
    for (var i = 1; i < tr.length; i++) {
        for (var j = 0; j < tr[i].cells.length; ++j) {
            var matched = false;
            if (tr[i].cells[j].innerHTML.toUpperCase().indexOf(filter) != -1) {
                tr[i].style.display = "";
                matched = true
                break;
            }
            if (!matched)
                tr[i].style.display = "none";
        }
    }
}
function sortDataFrame(id, n, dtype) {
    var table = document.getElementById("dataframe_" + id);
    var tb = table.tBodies[0]; // use `<tbody>` to ignore `<thead>` and `<tfoot>` rows
    var tr = Array.prototype.slice.call(tb.rows, 0); // put rows into array
    if (dtype === 'numeric') {
        var fn = function(a, b) { 
            return parseFloat(a.cells[n].textContent) <= parseFloat(b.cells[n].textContent) ? -1 : 1;
        }
    } else {
        var fn = function(a, b) {
            var c = a.cells[n].textContent.trim().localeCompare(b.cells[n].textContent.trim()); 
            return c > 0 ? 1 : (c < 0 ? -1 : 0) }
    }
    var isSorted = function(array, fn) {
        if (array.length < 2)
            return 1;
        var direction = fn(array[0], array[1]); 
        for (var i = 1; i < array.length - 1; ++i) {
            var d = fn(array[i], array[i+1]);
            if (d == 0)
                continue;
            else if (direction == 0)
                direction = d;
            else if (direction != d)
                return 0;
            }
        return direction;
    }
    var sorted = isSorted(tr, fn);
    if (sorted == 1 || sorted == -1) {
        // if sorted already, reverse it
        for(var i = tr.length - 1; i >= 0; --i)
            tb.appendChild(tr[i]); // append each row in order
    } else {
        tr = tr.sort(fn);
        for(var i = 0; i < tr.length; ++i)
            tb.appendChild(tr[i]); // append each row in order
    }
}
</script>

<script>
$( document ).ready(function(){
            var cfg={'threshold':3,     // depth of toc (number of levels)
             'number_sections': false,
             'toc_cell': false,          // useless here
             'toc_window_display': true, // display the toc window
             "toc_section_display": "block", // display toc contents in the window
             'sideBar':true,       // sidebar or floating window
             'navigate_menu':false       // navigation menu (only in liveNotebook -- do not change)
            }
            var st={};                  // some variables used in the script
            st.rendering_toc_cell = false;
            st.config_loaded = false;
            st.extension_initialized=false;
            st.nbcontainer_marginleft = $('#notebook-container').css('margin-left')
            st.nbcontainer_marginright = $('#notebook-container').css('margin-right')
            st.nbcontainer_width = $('#notebook-container').css('width')
            st.oldTocHeight = undefined
            st.cell_toc = undefined;
            st.toc_index=0;
            // fire the main function with these parameters
            table_of_contents(cfg, st);
            var file=tutorialsDict[$("h1:first").attr("id")];
            $("#toc-level0 a").css("color","#126dce");
            $('a[href="#'+$("h1:first").attr("id")+'"]').hide()
            var docs=tutorialsArray;
            var docs_map=tutorialsArrayMap;
            var pos=tutorialsArray.indexOf(file);
            for (var a=pos;a>=0;a--){
                  $('<li><a href="'+docs[a]+'.html"><font color="#073642"><b>'+docs_map[docs[a]].replace(/_/g," ")+'</b></font></a></li>').insertBefore("#toc-level0 li:eq(0)");
            }
            $('a[href="'+file+'.html'+'"]').css("color","#126dce");
            for (var a=pos+1;a<docs.length;a++){
                  $(".toc #toc-level0").append('<li><a href="'+docs[a]+'.html"><font color="#073642"><b>'+docs_map[docs[a]].replace(/_/g," ")+'</b></font></a></li>');
            }
            // $("#toc-header").hide(); // comment out because it prevents search bar from displaying
    });
</script>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');
  // mark it active
  menuAnchor.parent().addClass('active');
  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>
<div class="container-fluid main-container">
<!-- tabsets -->
<script src="../site_libs/navigation-1.1/tabsets.js"></script>
<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});
</script>



<title>Dynamic Statistical Comparisons</title>

<style type = "text/css">
body {
  font-family: "Droid Sans";
  padding-top: 66px;
  padding-bottom: 40px;
}
</style>
</head>

<body>
<div tabindex="-1" id="notebook" class="border-box-sizing">
<div class="container" id="notebook-container">

<!-- code folding -->

<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="../index.html">Dynamic Statistical Comparisons</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        
<li>
  <a href="../index.html">Home</a>
</li>
        
<li>
  <a href="../tutorials.html">Tutorials</a>
</li>
        
<li>
  <a href="../installation.html">Installation</a>
</li>
        
<li>
  <a href="../FAQ.html">FAQ</a>
</li>
        
<li>
  <a href="../examples.html">Examples</a>
</li>
        
<li>
  <a href="../reference.html">Reference</a>
</li>
        
      </ul>
        
<ul class="nav navbar-nav navbar-right">
<li>
   <a href="https://github.com/stephenslab/dsc"> <span class="fa fa-github"></span> </a>
</li>
</ul>
        
      </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="DSC-Basics,-Part-I">DSC Basics, Part I<a class="anchor-link" href="#DSC-Basics,-Part-I">&#182;</a></h1><p>This is a continuation of the <a href="Intro_DSC.html">Introduction to DSC</a>. Here we revisit the same example from the first part to illustrate key concepts of DSC, including <em>modules</em>, <em>groups</em> and <em>pipeline variables</em>. More advanced concepts will be introduced in <a href="Intro_Syntax_II.html">Part II</a>.</p>
<p>Materials used in this tutorial can be found in the <a href="https://github.com/stephenslab/dsc/tree/master/vignettes/one_sample_location">DSC vignettes repository</a>. As before, you may choose to run this example DSC program as you read through the tutorial, but it is not required. For more details, consult the README in the <a href="https://github.com/stephenslab/dsc/tree/master/vignettes/one_sample_location">"one sample location" DSC vignette</a>.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Pipeline-variables">Pipeline variables<a class="anchor-link" href="#Pipeline-variables">&#182;</a></h2><p>In DSC, all information is passed from one module to another through <em>pipeline variables</em>. All pipeline variables are indicated with a <code>$</code> as the first character, as in <code>$data</code> or <code>$mean_test_error</code>.</p>
<p>Under the hood, when a module outputs a pipeline variable, the value of this variable is saved to a file; and when a pipeline variable is provided as input to a module, the value of this variable is read from a file. You will never need to access these files directly; DSC provides a user interface that allows you to access (<em>i.e.</em>, query) the pipeline variables without having to know where or how they are stored. In the previous tutorial we illustrated how the pipeline variables can be queried in R.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Planning-a-DSC-file">Planning a DSC file<a class="anchor-link" href="#Planning-a-DSC-file">&#182;</a></h2><p>The main aim of DSC is to make your benchmark, or computational experiment, easier to read, easier to maintain, and easier to extend. To achieve these aims, we recommend that you to start by planning out your DSC project.</p>
<p>We suggest starting the planning by identifying the <em>module types</em> (the key computational steps in your benchmark) and the <em>pipeline variables</em> (the quantities being fed from one step to another). All pipeline variables should be given informative names (which must begin with a <code>$</code>). It is also helpful to give the modules informative names. (<em>Note:</em> unlike other programming languages such as R, names in DSC cannot have a period.)</p>
<p>Recall, in our working example, that we compared methods for estimating a population mean from a simulated data sample. This example followed the <strong>simulate-analyze-score</strong> design pattern, meaning that the benchmark could be naturally decomposed into three module types:</p>
<ul>
<li><p>A <code>simulate</code> module that generates a vector of simulated data (<code>$data</code>), and the population mean setting used to simulate these data (<code>$true_mean</code>).</p>
</li>
<li><p>An <code>analyze</code> module that accepts <code>$data</code> as input, and outputs an estimate of the population mean (<code>$est_mean</code>).</p>
</li>
<li><p>A <code>score</code> module that accepts inputs <code>$est_mean</code> and <code>$true_mean</code>, and outputs an error measure (<code>$error</code>).</p>
</li>
</ul>
<p>Therefore, our DSC has four pipeline variables: <code>$data</code>, <code>$true_mean</code>, <code>$est_mean</code> and <code>$error</code>.</p>
<p>For clarity, we have summarized this information in the comments at the top of the DSC file (the <code>#</code> character indicates a comment in a DSC file—anything after a <code>#</code> is ignored by DSC):</p>

<pre><code># PIPELINE VARIABLES
# $data       simulated data (vector)
# $true_mean  population mean used to simulate $data (scalar)
# $est_mean   population mean estimate (scalar)
# $error      error in the estimate (scalar)
#
# MODULE TYPES
# name     inputs                outputs
# ----     ------                -------
# simulate none                  $data, $true_mean
# analyze  $data                 $est_mean
# score:   $est_mean, $true_mean $error</code></pre>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Two-important-notes-about-pipeline-variables">Two important notes about pipeline variables<a class="anchor-link" href="#Two-important-notes-about-pipeline-variables">&#182;</a></h2><ol>
<li><p>The variables outputted by modules should also include the parts of your benchmark that you want stored for future use. For example, <code>$error</code> is here considered a module output since we would like to use this quantity to study the results of the experiment.</p>
</li>
<li><p><em>The pipeline variables are the only way that modules can communicate with one another.</em> So if a module requires access to a piece of information generated by a previous module, then this must be a pipeline variable. For example, a <code>score</code> module requires access to the true mean used to generate the data, so here this quantity is assigned to a pipeline variable <code>$true_mean</code> from a <code>simulate</code> module.</p>
</li>
</ol>
<p>In summary, <em>all information in a DSC program is local to each module unless it is defined as a module output and assigned to a pipeline variable using the <code>$</code> character.</em></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Defining-modules-in-a-DSC-file">Defining modules in a DSC file<a class="anchor-link" href="#Defining-modules-in-a-DSC-file">&#182;</a></h2><p>At its simplest, a DSC module definition consists of a name, a script (code) implementing the module, and details of how quantities are to be passed in and out of each script.</p>
<p>Here we illustrate the syntax by explaining each module in our example. To keep the presentation focused on the key concepts, we use a slightly simplified version of the <a href="Intro_DSC.html">mean estimation example</a> that achieves the same
result; see file <code>first_investigation_simpler.dsc</code> in the <a href="https://github.com/stephenslab/dsc/tree/master/vignettes/one_sample_location">DSC vignettes repository</a> for the full example.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="The-normal-module">The <code>normal</code> module<a class="anchor-link" href="#The-normal-module">&#182;</a></h3><p>The first module defined in the DSC file is the <code>normal</code> module:</p>

<pre><code>normal: R(x &lt;- rnorm(n = 100,mean = 0,sd = 1))
  $data: x
  $true_mean: 0</code></pre>
<p>(Again, this code is simplified slightly from the previous tutorial, but it achieves the same result.)</p>
<p>This code tells DSC three things:</p>
<ol>
<li><p>The name of the module is "normal".</p>
</li>
<li><p>The R script implementing the module is a single line of code: <code>x &lt;- rnorm(n,mean = 100,sd = 1)</code>. Here, <code>R()</code> tells DSC that this code should be parsed and evaluated as an R script. For longer code, this should be replaced with the name of a file containing the R code. Any global variables (that is, variables that are not local to a function) defined inside a script are called "script variables"; in this module, one script variable is defined, <code>x</code>.</p>
</li>
<li><p>After running the script, the pipeline variable <code>$data</code> is set to the value of script variable <code>x</code>. A second pipeline variable, <code>$true_mean</code>, is set to 0.</p>
</li>
</ol>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="The-t-module">The <code>t</code> module<a class="anchor-link" href="#The-t-module">&#182;</a></h3><p>The <code>t</code> module has the same outputs as the <code>normal</code> module, but generates <code>$data</code> from a <em>t</em> distribution with a mean of 3 and 2 degrees of freedom. After running the script, the pipeline variable <code>$data</code> is assigned the value of script variable <code>x</code>, and <code>$true_mean</code> is set to 0.</p>
<p>Here is the code:</p>

<pre><code>t: R(x &lt;- 3 + rt(n = 100,df = 2))
  $data: x
  $true_mean: 3</code></pre>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="The-two-analyze-modules">The two <code>analyze</code> modules<a class="anchor-link" href="#The-two-analyze-modules">&#182;</a></h3><p>Our example has two <code>analyze</code> modules: the <code>mean</code> module estimates the population mean by the sample mean, and the <code>median</code> module estimates the population mean by the sample median.</p>
<p>They are defined in the DSC file as follows:</p>

<pre><code>mean: R(y &lt;- mean(x))
  x: $data
  $est_mean: y

median: R(y &lt;- median(x))
  x: $data
  $est_mean: y</code></pre>
<p>These modules differ from the <code>simulate</code> modules in that they have inputs in addition to outputs:</p>
<ul>
<li><p>The line <code>x: $data</code> specifies a module input. It tells DSC that, before running the R code, it should define a new global variable <code>x</code> in the R environment, and set the value of <code>x</code> to the value of the pipeline variable <code>$data</code>. The value of <code>$data</code> is given by the most recently run module in the pipeline that assigned a value to <code>$data</code>.</p>
</li>
<li><p>The line <code>$est_mean: y</code> specifies a module output. It tells DSC that after running the script it should set the value of the pipeline variable <code>$est_mean</code> to the value of the script variable <code>y</code>.</p>
</li>
</ul>
<p><strong>Important note:</strong> Although the R code in the <code>normal</code>, <code>t</code>, <code>median</code> and <code>mean</code> modules all define a script variable <code>x</code>, these variables are distinct (<em>i.e.</em>, they are <em>local</em> to each module), and we must use a pipeline variable (here we use <code>$data</code>) to pass the information on <code>x</code> from one script to another.</p>
<p>In summary, all script variables are local to each module, and information can flow from one module to another only through pipeline variables.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="The-two-score-modules">The two <code>score</code> modules<a class="anchor-link" href="#The-two-score-modules">&#182;</a></h3><p>Finally, we create two <code>score</code> modules that measure error in the estimate, one based on squared differences (<code>sq_err</code>) and another based on absolute differences (<code>abs_err</code>):</p>

<pre><code>sq_err: R(e &lt;- (x - y)^2)
  x: $est_mean
  y: $true_mean
  $error: e

abs_err: R(e &lt;- abs(x - y))
  x: $est_mean
  y: $true_mean
  $error: e</code></pre>
<p>The inputs to both modules are <code>$est_mean</code> and <code>$true_mean</code>, and the output is <code>$error</code>.</p>
<p>In each of these modules, there are three script variables:</p>
<ol>
<li><p><code>x</code> is set to the current value of pipeline variable <code>$est_mean</code>.</p>
</li>
<li><p><code>y</code> is set to the current value of pipeline variable <code>$true_mean</code>.</p>
</li>
<li><p><code>e</code> is determined by the R code, and its value is assigned to pipeline variable <code>$error</code>.</p>
</li>
</ol>
<p>This completes the module definitions.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Defining-groups-and-pipelines">Defining groups and pipelines<a class="anchor-link" href="#Defining-groups-and-pipelines">&#182;</a></h2><p>So far, we have defined the modules—that is, the individual computational steps of the DSC experiment—but we have not yet described how these modules relate to each other, and how they are used to build pipelines. This is the purpose of the <code>DSC</code> block in the DSC file; the key components of the <code>DSC</code> block are the <code>define</code> and <code>run</code> statements.</p>

<pre><code>DSC:
  define:
    simulate: normal, t
    analyze: mean, median
    score: abs_err, sq_err
  run: simulate * analyze * score</code></pre>
<p>This code does the following:</p>
<ol>
<li><p><code>DSC</code> is a special keyword indicating that we are defining the module groups and pipelines (that is, we are not defining a module).</p>
</li>
<li><p><code>define</code> is another keyword indicating that we are defining module groups.</p>
</li>
<li><p>We define three module groups: <code>simulate</code>, <code>analyze</code> and <code>score</code>. The defining characteristic of module groups is that they should have a similar function (and, in the simplest case, the same inputs and outputs, although this is not required).</p>
</li>
<li><p><code>run</code> is a keyword indicating that we are defining the computational pipelines (sequences of modules) to be executed.</p>
</li>
<li><p>The <code>A * B</code> notation asks DSC to generate all possible sequences of modules from groups <code>A</code> and <code>B</code>; that is, all sequences of the form (<code>a</code>, <code>b</code>) where <code>a</code> is a module in group <code>A</code> and <code>b</code> is a module in a group <code>B</code>. So, in this example, <code>simulate * analyze * score</code> generates all pipelines that consist of a module from the <code>simulate</code> group (<code>normal</code> or <code>t</code>), followed by a module from the <code>analyze</code> group (<code>mean</code> or <code>median</code>), and then a module from the <code>score</code> group (<code>sq_err</code> or <code>abs_err</code>). <strong>In this example, there are $2 \times 2 \times 2 = 8$ different pipelines defined by this <code>run</code> statement.</strong></p>
</li>
</ol>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Executing-the-DSC-benchmark">Executing the DSC benchmark<a class="anchor-link" href="#Executing-the-DSC-benchmark">&#182;</a></h2><p>Up to this point, all we have is a bunch of code stored in a text file; the DSC file doesn't do anything unless it is interpreted and executed by the <code>dsc</code> program.</p>
<p>The <code>dsc</code> program will run all 8 pipelines, keeping track of the values of all the script variables and pipeline variables generated in each pipeline, and it will store the values of all the module outputs, which we will retrieve for analysis in R.</p>
<p>To run the DSC benchmark, change the working directory to the location of the <code>first_investigation_simpler.dsc</code> file. (Here we assume the <code>dsc</code> repository is stored in the <code>git</code> subdirectory of your home directory. If you are running the example yourself, please move to the appropriate directory on your computer.)</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[4]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-sos"><pre><span></span><span class="n">cd</span> <span class="o">~/</span><span class="n">git</span><span class="o">/</span><span class="n">dsc</span><span class="o">/</span><span class="n">vignettes</span><span class="o">/</span><span class="n">one_sample_location</span>
<span class="n">pwd</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt"></div>


<div class="output_subarea output_stream output_stdout output_text">
<pre>/Users/pcarbo/git/dsc/vignettes/one_sample_location
</pre>
</div>
</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Let's also remove any previously generated results.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[5]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-sos"><pre><span></span><span class="n">rm</span> <span class="o">-</span><span class="n">Rf</span> <span class="n">first_investigation</span><span class="o">.</span><span class="n">html</span> <span class="n">first_investigation</span><span class="o">.</span><span class="n">log</span> <span class="n">first_investigation</span>
</pre></div>

</div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>To keep this example as simple as possible, generate only a single replicate for each of the pipelines, and execute in parallel at most 2 modules at any one time:</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[6]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-sos"><pre><span></span><span class="n">dsc</span> <span class="n">first_investigation_simpler</span><span class="o">.</span><span class="n">dsc</span> <span class="o">--</span><span class="n">replicate</span> <span class="mi">1</span> <span class="o">-</span><span class="n">c</span> <span class="mi">2</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt"></div>


<div class="output_subarea output_stream output_stdout output_text">
<pre><span class="ansi-green-intense-fg ansi-bold">INFO: Checking R library dscrutils@stephenslab/dsc/dscrutils ...</span>
INFO: DSC script exported to <span class="ansi-green-fg">first_investigation.html</span>
INFO: Constructing DSC from <span class="ansi-green-fg">first_investigation_simpler.dsc</span> ...
INFO: Building execution graph &amp; running DSC ...
DSC: 100%|██████████████████████████████████████| 15/15 [00:06&lt;00:00,  2.98it/s]
INFO: Building DSC database ...
INFO: DSC complete!
INFO: Elapsed time <span class="ansi-green-fg">9.614</span> seconds.
</pre>
</div>
</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><em>TO DO: Add a sentence here pointing out the number of module outputs that were generated by this command.</em></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Inspecting-the-results-of-the-DSC-benchmark">Inspecting the results of the DSC benchmark<a class="anchor-link" href="#Inspecting-the-results-of-the-DSC-benchmark">&#182;</a></h2><p>To inspect the outcomes generated by each of the 8 pipelines, change the R working directory to the location of the DSC file, and use the <code>dscquery</code> function from the <code>dscrutils</code> package to load the DSC results into R:</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[7]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-sos"><pre><span></span><span class="n">setwd</span><span class="p">(</span><span class="s2">&quot;~/git/dsc/vignettes/one_sample_location&quot;</span><span class="p">)</span>
<span class="n">library</span><span class="p">(</span><span class="n">dscrutils</span><span class="p">)</span>
<span class="n">dscout</span> <span class="o">&lt;-</span>
  <span class="n">dscquery</span><span class="p">(</span><span class="n">dsc</span><span class="o">.</span><span class="n">outdir</span> <span class="o">=</span> <span class="s2">&quot;first_investigation&quot;</span><span class="p">,</span>
           <span class="n">targets</span> <span class="o">=</span> <span class="n">c</span><span class="p">(</span><span class="s2">&quot;simulate.true_mean&quot;</span><span class="p">,</span><span class="s2">&quot;analyze.est_mean&quot;</span><span class="p">,</span><span class="s2">&quot;score.error&quot;</span><span class="p">))</span>
<span class="n">dscout</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt"></div>


<div class="output_subarea output_stream output_stdout output_text">
<pre>Running shell command:
dsc-query first_investigation -o /var/folders/9b/ck4lp8s140lcksryyh4dppdr0000gn/T//Rtmp9mHzAk/file6a71378f8db0.csv -f --target simulate.true_mean analyze.est_mean score.error 
Loading dsc-query output from CSV file.
Reading DSC outputs:
 - simulate.true_mean: extracted atomic values
 - analyze.est_mean: extracted atomic values
 - score.error: extracted atomic values
</pre>
</div>
</div>

<div class="output_area">

<div class="prompt"></div>



<div class="output_html rendered_html output_subarea ">
<table>
<thead><tr><th scope=col>DSC</th><th scope=col>simulate</th><th scope=col>simulate.true_mean</th><th scope=col>analyze</th><th scope=col>analyze.est_mean</th><th scope=col>score</th><th scope=col>score.error</th></tr></thead>
<tbody>
	<tr><td>1        </td><td>normal   </td><td>0        </td><td>mean     </td><td>0.05858  </td><td>abs_err  </td><td>0.0585762</td></tr>
	<tr><td>1        </td><td>normal   </td><td>0        </td><td>median   </td><td>0.03087  </td><td>abs_err  </td><td>0.0308732</td></tr>
	<tr><td>1        </td><td>t        </td><td>3        </td><td>mean     </td><td>2.70521  </td><td>abs_err  </td><td>0.2947856</td></tr>
	<tr><td>1        </td><td>t        </td><td>3        </td><td>median   </td><td>2.93084  </td><td>abs_err  </td><td>0.0691572</td></tr>
	<tr><td>1        </td><td>normal   </td><td>0        </td><td>mean     </td><td>0.05858  </td><td>sq_err   </td><td>0.0034312</td></tr>
	<tr><td>1        </td><td>normal   </td><td>0        </td><td>median   </td><td>0.03087  </td><td>sq_err   </td><td>0.0009532</td></tr>
	<tr><td>1        </td><td>t        </td><td>3        </td><td>mean     </td><td>2.70521  </td><td>sq_err   </td><td>0.0868985</td></tr>
	<tr><td>1        </td><td>t        </td><td>3        </td><td>median   </td><td>2.93084  </td><td>sq_err   </td><td>0.0047827</td></tr>
</tbody>
</table>

</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The results in this table illustrate a few essential features of a DSC program:</p>
<ol>
<li><p>Looking at the "simulate", "analyze" and "score" table columns, we can confirm that DSC has run 8 different pipelines. Each pipeline runs a different combination of the <code>simulate</code>, <code>analyze</code> and <code>score</code> modules.</p>
</li>
<li><p><strong>In DSC, each module input and output is assigned a different value within each pipeline.</strong> This is very different from most programs where each variable is assigned a single value. For example, <code>score.error</code> has 8 different values for each of the 8 different pipelines. (We did not include the <code>simulate.data</code> module output in this table because it is too large to show here, but its can value can be extracted like the other outputs.)</p>
</li>
<li><p><strong>Information flows between modules within the same pipeline.</strong> In the first pipeline (the first row of the table), for example, the error in the <code>abs_err</code> module (0.05858) is calculated from (1) the value of the true mean, which was set to 0 in the <code>normal</code> module, and (2) from the estimated mean, which was set to 0.05858 in the <code>mean</code> module.</p>
</li>
</ol>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Pipeline-evaluation,-and-alternatives">Pipeline evaluation, and <em>alternatives</em><a class="anchor-link" href="#Pipeline-evaluation,-and-alternatives">&#182;</a></h2><p>In the previous section, we observed that DSC generated 8 pipelines, in which each 8 pipeline is different combination of modules, and contains a different set of results. Now we explain at a high level how DSC produced these results.</p>
<ol>
<li><p>DSC runs the two <code>simulate</code> modules, <code>normal</code> and <code>t</code>, then stores the values assigned to <code>$true_mean</code> and <code>$data</code>. Therefore, the module outputs <code>$true_mean</code> and <code>$data</code> have two <strong>alternative values</strong>: the value assigned by running the <code>normal</code> module, and the value assigned by running the <code>t</code> module. (For example, the alternative values of <code>$true_mean</code> are 0 and 3.) <code>normal</code> and <code>t</code> are <strong>alternative modules</strong> in the <code>simulate</code> group. Therefore, although the <code>normal</code> module appears in 4 pipelines, and the <code>t</code> module also appears in 4 pipelines, each <code>simulate</code> module only needs to be run once.</p>
</li>
<li><p>DSC runs the two <code>analyze</code> modules, <code>mean</code> and <code>median</code>, then stores the values assigned to the  module output, <code>$est_mean</code>. The <code>mean</code> module is run twice, once for each alternative value of <code>$data</code> (the value of <code>$data</code> is assigned to module input <code>x</code> in the <code>mean</code> and <code>median</code> modules). Likewise, the <code>median</code> module is run twice, once for each alternative value of <code>$data$</code>. Therefore, the <code>analyze</code> step is evaluated 4 times in total, and the module output <code>$est_mean</code> has 4 alternative values. If you look closely at the <code>dscout</code> data frame above, you will see that the <code>analyze.est_mean</code> contains 4 unique values.</p>
</li>
<li><p>DSC runs the two <code>score</code> modules, <code>sq_err</code> and <code>abs_err</code>. These modules both accept two pipeline variables as input, <code>$est_mean</code> and <code>$true_mean</code>. Since there are 4 alternative assignments to both <code>$est_mean</code> and <code>$true_mean</code>, each <code>score</code> module is evaluated 4 times, so in the end DSC stores 8 different values for the final module output, <code>$error</code>.</p>
</li>
</ol>
<p>A naive approach would have been to run the <code>simulate</code> step 8 times, the <code>analyze</code> step 8 times, and the <code>score</code> step 8 times, but that would have been a waste of time, since many of the computations would be redundant. DSC performs the minimum amount of computation needed to generate the results for all the pipelines by generalizing the steps described here. Although wasted computation will have little noticeable effect on a small experiment such as this, this could be very important when large data sets are being simulated and analyzed.</p>
<p>Note that, under the hood, the order of evaluation may not be exactly as we described it here—for example, the <code>mean</code> and <code>median</code> modules might be evaluated with the output from <code>mean</code> before the <code>t</code> module is availabled—but the exact order of evaluation is unimportant for understanding how the DSC results are generated.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Recap">Recap<a class="anchor-link" href="#Recap">&#182;</a></h2><p>In this tutorial, we learned how the DSC file is used to define the key components of a DSC experiment:</p>
<ol>
<li><p>Module inputs and outputs (pipeline variables);</p>
</li>
<li><p>Module scripts and script variables.</p>
</li>
<li><p>Module groups; and</p>
</li>
<li><p>Module sequences (pipelines).</p>
</li>
</ol>
<p>We also learned:</p>
<ol>
<li><p>How information flows between modules executed in a pipeline;</p>
</li>
<li><p>How values are assigned to pipeline variables separately in each pipeline.</p>
</li>
<li><p>How modules are evaluated, and how alternative values of module outputs are stored.</p>
</li>
</ol>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Next-steps">Next steps<a class="anchor-link" href="#Next-steps">&#182;</a></h2><p>In <a href="Intro_Syntax_II.html">Part II</a>, we will
extend this example and introduce a few other useful DSC features.</p>
<!-- You can think of a pipeline variable as a variable whose value
may change as a pipeline is run. For example, in a pipeline `a-b-c`,
with modules `a`, `b` and `c`, if module `a` outputs a pipeline
variable `$data`, and then module `b` outputs `$data` with a new
value, then if module `c` inputs `$data` its value will be the one
output by `b` and not the one output by `a`. -->
</div>
</div>
</div>
<hr>
Copyright (c) 2016-2018 <a href="http://home.uchicago.edu/gaow">Gao Wang</a>, <a href="http://stephenslab.uchicago.edu">Matthew Stephens</a>, <a href="https://pcarbo.github.io">Peter Carbonetto</a> and contributors.<br>&nbsp;&nbsp;&nbsp; Except where otherwise noted, this website is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.

</div>
</div>
</body>
</html>
