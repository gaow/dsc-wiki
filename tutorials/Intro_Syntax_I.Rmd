---
title: "Introduction to DSC (Part II)"
author: "Matthew Stephens, Gao Wang and Peter Carbonetto"
date: "March 21, 2018"
output: html_document
---

# Introduction to DSC (Part II)

This is a continuation of the [Introduction to DSC (Part
I)](First_Course.html). Here we use the same example from the first
part to illustrate three key concepts of DSC: *modules*, *groups*
and *pipeline variables*. More advanced concepts will be introduced
in [Part III]().

Materials used in this tutorial can be found in the [DSC vignettes
repository](https://github.com/stephenslab/dsc/tree/master/vignettes/one_sample_location).

## Pipeline variables

In DSC, all information is passed from one module to another through
*pipeline variables*. All pipeline variables are indicated with a `$`
as the first character, as in `$data` or `$mean_test_error`.

Under the hood, when a module outputs a pipeline variable, the value
of this variable is saved to a file; and when a pipeline variable is
provided as input to a module, the value of this variable is read from
a file. You will never need to access these files directly; DSC
provides a user interface that allows you to access (*i.e.*, query)
the pipeline variables without having to know which files they come
from, or how the pipeline variables are stored in these files. We have
given an example of the user interface in the [previous
tutorial](Intro_DSC.html).

## Planning a DSC file

The main aim of DSC is to make your benchmark easier to read, easier
to maintain, and easier to extend. To achieve these aims, we recommend
that you to start by planning out your DSC project.

We suggesting starting the plan by identifying the *module types* (the
key computation steps in your benchmark) and the *pipeline variables*
(the quantities being passed from module to another). All pipeline
variables should be given informative names (which must begin with a
`$`). It is also helpful to give the modules informative names.
(*Note:* unlike some other programming languages, such as R, names in
DSC cannot have a period, which is reserved for another use.)

In our working example, recall that we are comparing methods for
estimating a population mean from a simulated data sample. This
example follows the **simulate-analyze-score** design pattern, meaning
that the benchmark can be naturally decomposed in three types of
module:

+ A `simulate` module that generates a vector of simulated data
(`$data`), and the population mean setting used to simulate these data
(`$true_mean`).

+ An `analyze` module that accepts `$data` as input, and outputs an
estimate of the population mean (`$est_mean`).

+ A `score` module that accepts inputs `$est_mean` and `$true_mean`
and outputs an error measure (`$error`).

Therefore, our DSC has four pipeline variables:
`$data`,`$true_mean`,`$est_mean` and `$error`.

We have summarized this information in the comments at the top of the
DSC file (the `#` character indicates a comment in a DSC
fileâ€”anything after a `#` is ignored by DSC):

```
# PIPELINE VARIABLES
# $data       simulated data (vector)
# $true_mean  population mean used to simulate $data (scalar)
# $est_mean   population mean estimate (scalar)
# $error      error in the estimate (scalar)
# 
# MODULE TYPES
# name     inputs                outputs
# ----     ------                -------
# simulate none                  $data, $true_mean
# analyze  $data                 $est_mean
# score:   $est_mean, $true_mean $error
```

## A couple important notes about pipeline variables

1. The pipeline variables outputted by a module should be exactly the
parts of the module output that you want stored for future use. For
example, `$error` is here considered a pipeline variable since we
would like to use this quantity to study the results of the
experiment.

2. The pipeline variables are the only way that modules can
communicate with one another. So if a module requires access to a
piece of information generated by a previous module, then this must be
a pipeline variable. For example, a `score` module naturally requires
access to the true mean used to generate the data, so here this is
outputted as a pipeline variable from a `simulate` module.

## Defining modules in DSC file

At its simplest, a DSC module definition consists of a name, a script
(code) implementing the module, and details of how pipeline variables
are to be passed in and out of the script.

Here we illustrate the syntax by explaining each module in our example.

### The `normal` module

The first module defined in the DSC file is the `normal` module:

```
normal: R(x <- rnorm(n = 100,mean = 0,sd = 1))
  $data: x
  $true_mean: 0
```

(Note that this code is simplified slightly from the previous
tutorial, but it achieves the same result.)

This code tells DSC three things:

1. The name of the module is "normal".

2. The R script implementing the module is a single line of code:
   `x <- rnorm(n,mean = mu,sd = 1)`. Here, `R()` tells DSC that this
   code should be parsed and evaluated in R. For longer code, this
   should be replaced with a name of a file containing the R
   code. Any variables defined inside a script are called "script
   variables"; in this module, there one script variable is defined,
   `x`.

3. After running the script, the pipeline variable `$data` is
   determined by the value of script variable `x`, and the pipeline
   variable `$true_mean` is set to 0.

### The `t` module

The `t` module has the same outputs as the `normal` module, but
generates `$data` from a *t* distribution with a mean of 3 and 2
degrees of freedom.

Here is the code (again, simplified slightly from the previous
tutorial):

```
t: R(x <- 3 + rt(n = 100,df = 2))
  $data: x
  $true_mean: 3
```

### The two `analyze` modules

Our example has two `analyze` modules: the `mean` module estimates the
population mean by the sample mean, and the `median` module estimates
the population mean by the sample median.

They are defined in the DSC file as follows:

```
mean: R(y <- mean(x))
  x: $data
  $est_mean: y
  
median: R(y <- median(x))
  x: $data
  $est_mean: y
```

These modules differ from the `simulate` modules in that they have
inputs in addition to outputs:

+ The line `x: $data` specifies a module input. It tells DSC that,
  before running the R code, it should set the script variable `x` to
  the value of the pipeline variable `$data` (the value of `$data` is
  given by the most recently run module in the pipeline that output
  `$data`).

+ The lines `$est_mean: y` specifies a module output. It tells DSC
  that after running the script it should set the value of the
  pipeline variable `$est_mean` to the value of the script variable
  `y`.

**Note:** Although the R code in the `normal`,`t`,`median` and `mean`
modules all use a script variable `x`, these variables are distinct,
and we must use a pipeline variable (here `$data`) to pass the
information on `x` from one script to another. Information can flow
from one module to another only through pipeline variables.

### The two `score` modules

Finally, we create two `score` modules that measure error in the
estimate, one based on squared differences (`sq_err`) and another
based on absolute differences (`abs_err`):

```
sq_err: R(e <- (x - y)^2)
  x: $est_mean
  y: $true_mean
  $error: e
 
abs_err: R(e <- abs(x - y))
  x: $est_mean
  y: $true_mean
  $error: e 
```

The inputs to both modules are `$est_mean` and `$true_mean`, and the
output is `$error`.

## Defining groups and pipelines

The final stage is to tell DSC how to combine these
six modules into pipelines. We do this by
first defining the "groups" of similar modules, and then
defining pipelines in terms of these groups. 

```
DSC:
    define:
      simulate: normal, t
      analyze: mean, median
      score: abs_err, sq_err
    run: simulate * analyze * score
    output: dsc_result
```

Here:

- `DSC` is a keyword to indicate that here we are defining groups and pipelines (not a module definition).
- `define` is a keyword to indicate we are defining groups.
(here `simulate`, `analyze` and `score`).
- `run` is a keyword to indicate that we are defining the pipelines to be run. The `A * B` notation means to create all possible sequences of modules from groups `A` and `B`. That is, all sequences of the form `a`-`b` where `a` is a module in group `A` and `b` is a module in a group `B`. So here
`simulate * analyze * score` generates all pipelines that consist of first a module from the `simulate` group (`normal` or `t`), then a module from `analyze` (`mean` or `median`) and then a module from the `score` group (`sq_err` or `abs_err`).
- `output` tells DSC where to save results.


<!----
You can think of a pipeline variable
as a variable whose value may change as a pipeline is run. For example, in a pipeline `a-b-c`, with modules `a`, `b` and `c`, 
if module `a` outputs a pipeline variable `$data`, and
then module `b` outputs `$data` with a new value,
then if module `c` inputs `$data` its value
will be the one output by `b` and not the one output by `a`. 
---->
