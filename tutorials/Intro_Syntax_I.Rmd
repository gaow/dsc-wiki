---
title: "dsc_intro.rmd"
author: "Matthew Stephens"
date: "2/26/2018"
output: html_document
---

# Introduction to DSC (Part II)

This is a continuation of the [Introduction to DSC (Part I)](First_Course.html). Here we use the example from that introduction to
illustrate three key concepts of DSC: "modules", "groups" and "pipeline variables". More advanced concepts will be introduced in [Part III](). 

Material used in this example are in [the DSC vignettes repo](https://github.com/stephenslab/dsc/tree/master/vignettes/one_sample_location).


## Module input/output; pipeline variables

In DSC, information is passed from module to module
through "pipeline variables", which are indicated by using a name that begins with `$` (for example `$data`). 
Under the hood DSC keeps track of pipeline variable values by saving
them in files. Specifically, when a module outputs a pipeline variable, its value is saved in a file; and when a module inputs a pipeline variable its value is read from a file. The values of pipeline variables can also be retrieved from these files after the DSC is run. 

### Planning a DSC file

DSC is intended to help make benchmarks easier to read, maintain and extend. To achieve this it will be helpful
to start by doing some planning before writing a DSC file.

We suggesting starting the plan by identifying the *types of module* and the *pipeline variables* (i.e. the quantities being passed from module to module).
Pipeline variables should be given an informative name which must begin with a `$`. It may also be helpful to give names to the types of module.
(Note: names in DSC cannot have `.` character, which is reserved for another use.)

Recall that our example benchmark compares methods for estimating a population mean from a simulated sample, and follows the simple `simulate`-`analyze`-`score` design.
There are three different types of module:

+ a `simulate` module outputs a vector of simulated data (`$data`),  and the value of the population mean used to simulate it (`$true_mean`). 
+ an `analyze` module inputs `$data` and outputs an estimate (`$est_mean`) of the population mean.
+ a `score` module inputs `$est_mean` and `$true_mean` and output a measure of the error (`$error`).

Our DSC therefore has four pipeline variables: `$data`,`$true_mean`,`$est_mean` and `$error`. 

This information is summarized in comments at the top of the DSC file (the `#` character indicates a comment in a DSC file; anything after a `#` is ignored by DSC.)
```
# Pipeline variables
#
# $data: vector of simulated data
# $true_mean: scalar value of the population mean used to simulate $data 
# $est_mean:  scalar estimated value of the population mean
# $error: scalar measure of the accuracy of the estimate
#
#
# Module types
#
# simulate: . -> $data, $true_mean
# analyze: $data -> $est_mean
# score: $est_mean, $true_mean -> $error
```


### Notes on pipeline variables

1. The pipeline variables output by a module are exactly the parts of the module output that are saved (in a file) for future use. So `$error` is here considered a pipeline variable because we want it saved at the end of the pipeline. 

2. The pipeline variables are the only way that modules can communicate with one another. So if a module requires access to a piece of information generated by a previous module then this must be a pipeline variable. For example, a `score` module  naturally requires access to the true mean used to generate the data, so here this is output, as a pipeline variable, from a `simulate` module. 



## Specifying modules in DSC file

At its simplest, a DSC module definition 
consists of a name,  a script (code)
implementing the module, and details of how pipeline variables are to be
passed in and out of the script.

Here we illustrate the syntax by explaining each module in our example.

### The `normal` module

The first module defined in the DSC file is the `normal` module:
```
normal: R( x = rnorm(100,0,1) )
  $data: x
  $true_mean: 0
```

The syntax tells DSC three things:

- a name for the module (`normal`) 
- an R script containing the code for the module. Here `R()` tells DSC that this code is an R script. For longer scripts this would be replaced with a filename of the file containing the script. We refer to variables in scripts like this as "script variables", so here `x` is a script variable. 
- how to determine the values of the pipeline variables `$data` and `$true_mean` after running the script. Here we want `$data` to take the value of the script variable `x`, and `$true_mean` is 0.


### The `t` module

The `t` module is similar to the `normal` module, but
 generates 100 observations from a $t$ distribution with mean 3 and degrees of freedom 2.
Here is the specification:
```
t: R( 3 + rt(100, df=2) )
  $data: x
  $true_mean: 3
```

### Two `analyze` modules

Our example has two `analyze` modules: `mean` estimates the distribution mean by the sample mean; and `median` estimates the distribution mean by the sample median. 
They are defined in the DSC file as follows:
```
mean: R( y = mean(x) )
  x: $data
  $est_mean: y
  
median: R( y = median(x) )
  x: $data
  $est_mean: y
```

These modules differ from the `simulate` modules in that they have both input and output.
Specifically:

- The syntax `x: $data` specifies a module input. It tells DSC that, before running the script, it should set the script variable `x` to the value of the pipeline variable `$data` (which means the value of `$data` output by the most recent previous module that output `$data`).

- The syntax `$est_mean: y` specifies a module output. It tells DSC that after running the script it should set the value of the pipeline variable `$est_mean` to the value of the script variable `y` (similar to the `simulate` modules)

Note that although the scripts in `normal`,`t`,`median` and `mean` all use a script variable `x`, these variables are logically distinct, and we must use a pipeline variable
(here `$data`) to pass the information on `x` from one script to another. Information can
flow from one module to another only through pipeline variables.

### Two `score` modules

Finally we create two `score` modules, one based on squared error (`sq_err`) and one based on absolute error (`abs_err`):
```
sq_err: R( e = (a-b)^2 )
  a: $est_mean
  b: $true_mean
  $error: e
 
abs_err: R( e = abs(a-b) )
  a: $est_mean
  b: $true_mean
  $error: e 
```
  
## Defining groups and pipelines

The final stage is to tell DSC how to combine these
six modules into pipelines. We do this by
first defining the "groups" of similar modules, and then
defining pipelines in terms of these groups. 

```
DSC:
    define:
      simulate: normal, t
      analyze: mean, median
      score: abs_err, sq_err
    run: simulate * analyze * score
    output: dsc_result
```

Here:

- `DSC` is a keyword to indicate that here we are defining groups and pipelines (not a module definition).
- `define` is a keyword to indicate we are defining groups.
(here `simulate`, `analyze` and `score`).
- `run` is a keyword to indicate that we are defining the pipelines to be run. The `A * B` notation means to create all possible sequences of modules from groups `A` and `B`. That is, all sequences of the form `a`-`b` where `a` is a module in group `A` and `b` is a module in a group `B`. So here
`simulate * analyze * score` generates all pipelines that consist of first a module from the `simulate` group (`normal` or `t`), then a module from `analyze` (`mean` or `median`) and then a module from the `score` group (`sq_err` or `abs_err`).
- `output` tells DSC where to save results.


<!----
You can think of a pipeline variable
as a variable whose value may change as a pipeline is run. For example, in a pipeline `a-b-c`, with modules `a`, `b` and `c`, 
if module `a` outputs a pipeline variable `$data`, and
then module `b` outputs `$data` with a new value,
then if module `c` inputs `$data` its value
will be the one output by `b` and not the one output by `a`. 
---->